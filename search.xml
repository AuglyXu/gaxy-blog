<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Js八股文(持续更新)</title>
    <url>/2022/06/10/Js%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<p><em>只针对自己不太熟或者面试常问的有针对性的整理</em></p>
<h1 id="数据类型和检测方式"><a href="#数据类型和检测方式" class="headerlink" title="数据类型和检测方式"></a>数据类型和检测方式</h1><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p><code>Symbol</code>是ES6新出的数据结构</p>
<p>定义：<code>Symbol(&quot;key&quot;)</code></p>
<p>特点： 每次<code>Symbol(&#39;key&#39;)</code>都会生成一个唯一的值</p>
<p>获取：<code>Symbol.for(&#39;key&#39;)</code>，会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><code>typeof</code>注意点：只能检测原始类型(除了<code>null</code>)，不能检测引用类型(均为<code>&quot;object&quot;</code>)<br>原因：<code>null</code>比较特殊，为<code>000000</code>, 对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span></span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>a instanceof b</code>就是在a原型链上找是否有b的原型，找到位true, 否则为false</p>
<h3 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = left.__proto__</span><br><span class="line">    <span class="keyword">let</span> protoType = right.protoType</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node === protoType)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="对象转换规则"><a href="#对象转换规则" class="headerlink" title="对象转换规则"></a>对象转换规则</h3><ol>
<li>调用<code>[[Symbol.toPrimitive]]</code></li>
<li>调用<code>valueOf()</code></li>
<li>调用<code>toString()</code></li>
</ol>
<p>如果都没有返回基础类型，会报错。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换(==)"></a>隐式类型转换(==)</h3><p>个人总结规则：</p>
<ol>
<li><strong>同类型不转换</strong></li>
<li><strong>不同类型</strong>，一方为<code>string/number</code>, 另一方试图转换为<code>number</code>, 如果是对象，那么遵守上面的<strong>对象转换规则</strong></li>
<li>如果一方是<code>null/undefined</code>, 另一方必须是<code>null/undefined</code>, 否则为<code>false</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a ==<span class="number">3</span>);  <span class="comment">//true 连续调用规则二 Object隐式转换</span></span><br></pre></td></tr></table></figure>

<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><h2 id="指向问题"><a href="#指向问题" class="headerlink" title="指向问题"></a>指向问题</h2><ol>
<li><p>谁调用它，<code>this</code>指向谁</p>
</li>
<li><p>箭头函数的<code>this</code>指向箭头函数上层第一个普通函数的<code>this</code></p>
</li>
<li><p><code>new</code>关键字调用的构造函数的<code>this</code>始终指向创建出来的实例</p>
</li>
<li><p><code>apply</code>, <code>bind</code>, <code>call</code>可以改变<code>this</code>指针的指向，指向传递进去的第一个对象。<strong>注意：构造函数无法修改指针指向</strong></p>
</li>
</ol>
<h2 id="new相关"><a href="#new相关" class="headerlink" title="new相关"></a>new相关</h2><p><code>new</code>关键字执行以下几个步骤</p>
<ol>
<li><p>以构造函数的原型作为原型创建一个对象</p>
</li>
<li><p>将构造函数内部的<code>this</code>指向创建出来的对象，并调用构造函数</p>
</li>
<li><p>如果有返回值并且返回值为对象，那么返回， 否则将新创建出来的实例对象返回</p>
</li>
</ol>
<h2 id="手写bind和apply"><a href="#手写bind和apply" class="headerlink" title="手写bind和apply"></a>手写bind和apply</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">context, ...rest</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 没传就正常返回函数好了</span></span><br><span class="line">    <span class="keyword">if</span>(context === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">if</span>(!(context <span class="keyword">instanceof</span> <span class="built_in">Object</span>)) <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"上下文必须是对象"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> F()&#123;</span><br><span class="line">        <span class="comment">// 由于new出来的this指向的都是这个实例，实例 instanceof F为 true</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123; <span class="comment">// 如果是构造函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...rest)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F.apply(context, rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">context, ...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"fn"</span>) <span class="comment">// 避免重复</span></span><br><span class="line">    context[symbol] = fn</span><br><span class="line">    <span class="keyword">const</span> res = context.fn(...rest); <span class="comment">// 保证this指向context</span></span><br><span class="line">    <span class="keyword">delete</span> context[symbol]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h1><p>ES5有<em>全局作用域<em>和</em>函数作用域<em>，ES6新增</em>块级作用域</em></p>
<p>这里要注意<code>let</code>,<code>const</code>,<code>var</code>，暂时性死区、变量提升相关，不再赘述</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><ol>
<li><p><strong>编译阶段</strong>上下文已经形成</p>
</li>
<li><p>上下文中包括<em>变量对象VO</em>、<em>作用域链</em>、<em>this</em>指针的指向</p>
</li>
<li><p>作用域链保存在作用域<code>[[Scopes]]</code>属性中，即全局作用域就挂在window对象上，函数作用域保存在函数对象上</p>
</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>定义：外部函数能够访问内部函数定义的变量</p>
<p>本质：当前环境存在指向父级作用域的引用(全局作用域就是本身)</p>
<p>这里分类讨论：</p>
<ol>
<li>在函数作用域下的闭包</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = a()</span><br><span class="line"><span class="built_in">console</span>.dir(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> f函数上的[[Scopes]]如下</span></span><br><span class="line"><span class="comment"> [</span></span><br><span class="line"><span class="comment">     Closure:&#123;</span></span><br><span class="line"><span class="comment">         x: 1</span></span><br><span class="line"><span class="comment">     &#125;,</span></span><br><span class="line"><span class="comment">     Global:&#123;</span></span><br><span class="line"><span class="comment">         ...window相关变量</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> ]</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在全局作用域下的闭包</li>
</ol>
<blockquote>
<p>注意：可能有些人以为以下不是闭包，问题在于如下<br/><br><em>当前环境是否有指向父级作用域的变量(有！全局作用域的父级是本身)</em><br/><br><br/><br>因此他是闭包</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> f函数上的[[Scopes]]如下</span></span><br><span class="line"><span class="comment"> [</span></span><br><span class="line"><span class="comment">     Global:&#123;</span></span><br><span class="line"><span class="comment">          x: 1,</span></span><br><span class="line"><span class="comment">         ...window相关变量</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> ]</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure>

<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p><strong>全局作用域下</strong><code>let const</code>定义的变量比较特殊，在<code>[[Scopes]]</code>上的表现和其他不太一样，会单独定义一个对象<code>Script</code>, 存在那个上面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">fn的[[Scopes]]如下</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    Script: &#123;</span></span><br><span class="line"><span class="comment">        a: 1</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    Global:&#123;</span></span><br><span class="line"><span class="comment">        fn,</span></span><br><span class="line"><span class="comment">        ...其他window对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><p>一张图解释</p>
<p><img src="%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt=""></p>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p><code>require</code>导入，<code>module.exports</code>导出</p>
<p><code>module.exports</code>指向<code>exports</code></p>
<p>导出的都是值拷贝, 即导出后，导入值改变不会影响已经导出的值</p>
<h2 id="import和export"><a href="#import和export" class="headerlink" title="import和export"></a>import和export</h2><p><code>import</code> 导入 <code>export</code> 导出</p>
<p>需要<code>babel</code>转换</p>
<p>导出的都是引用拷贝, 即导出后，导入值改变会影响已经导出的值</p>
<h2 id="CMD和AMD"><a href="#CMD和AMD" class="headerlink" title="CMD和AMD"></a>CMD和AMD</h2><p><code>CMD</code>和<code>AMD</code>用的比较少了，两者都是用来解决异步加载的问题<br>区别在于：</p>
<ol>
<li><code>CMD</code>是就近依赖，<code>AMD</code>是依赖前置</li>
<li>依赖模块的执行实际，<code>AMD</code>已下载就执行(即<code>&#39;./a&#39;, &#39;./b&#39;</code>), <code>CMD</code>是需要的时候再执行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">"./b"</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line">define([<span class="string">"./a"</span>, <span class="string">"./b"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isComplexStruct = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deepClone = <span class="function">(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.constructor === <span class="built_in">Date</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj.constructor === <span class="built_in">RegExp</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hash.has(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取描述符</span></span><br><span class="line">    <span class="keyword">const</span> allDes = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDes)</span><br><span class="line"></span><br><span class="line">    hash.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownkeys(ownKeys))&#123;</span><br><span class="line">        cloneObj[key] = isComplexStruct(obj) ? deepClone(obj[key], hash) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn(...rest)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span>(nowTime - preTime &gt;= delay)&#123;</span><br><span class="line">            preTime = <span class="built_in">Date</span>.now()</span><br><span class="line">            <span class="keyword">return</span> fn(...rest)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>本质上是个接口，只要部署了<code>Symbol.iterator</code>的数据结构都是被认为是可遍历的，遍历的时候反复调用<code>next</code>方法</p>
<p>这个接口需要返回一个对象，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    next()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            value: xxx,</span><br><span class="line">            done: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ol>
<li><p>解决异步编程的痛点(回调地狱)</p>
</li>
<li><p>一旦状态改变了就不会改回来</p>
</li>
<li><p><code>Promise</code>调用是同步的，<code>.then</code>是异步的, 个人理解是创建<code>.then返回的Promise</code>状态这个过程是异步的</p>
</li>
</ol>
<p><img src="Promise.png" alt=""></p>
<h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><p>以下写一个简易版本, 注意点如下:</p>
<ol>
<li><p><code>Promise</code>本身是同步的, 传入的函数需要同步调用</p>
</li>
<li><p><code>resolveCallback, rejectCallback</code>的回调数组是为了处理异步情况</p>
</li>
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">        <span class="keyword">this</span>.onResolve = <span class="keyword">this</span>.onResolve.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.onReject = <span class="keyword">this</span>.onReject.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.resolveCallback = [];</span><br><span class="line">        <span class="keyword">this</span>.rejectCallback = [];</span><br><span class="line">        fn(<span class="keyword">this</span>.onResolve, <span class="keyword">this</span>.onReject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onResolve(val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.pending === <span class="string">'pending'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.pending = <span class="string">'fulfilled'</span></span><br><span class="line">            <span class="keyword">this</span>.value = val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>.resolveCallback.length)&#123;</span><br><span class="line">            <span class="keyword">this</span>.resolveCallback.shift()(<span class="keyword">this</span>.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onReject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.pending === <span class="string">'pending'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.pending = <span class="string">'reject'</span></span><br><span class="line">            <span class="keyword">this</span>.reason = reason</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">this</span>.rejectCallback.length)&#123;</span><br><span class="line">            <span class="keyword">this</span>.rejectCallback.shift()(<span class="keyword">this</span>.reason)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.protoType.then = <span class="function">(<span class="params">onResolve, onReject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.pending === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">            <span class="comment">// 这里处理开启微任务，等待返回的promise创建完成</span></span><br><span class="line">            <span class="comment">// queueMicrotask(() =&gt; &#123; // 这里暂时不展开了</span></span><br><span class="line">                onResolve(<span class="keyword">this</span>.value)</span><br><span class="line">            <span class="comment">// &#125;)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.pending === <span class="string">'reject'</span>)&#123;</span><br><span class="line">            onReject(<span class="keyword">this</span>.reason)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.pending === <span class="string">'pending'</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.resolveCallback.push(onResolve)</span><br><span class="line">            <span class="keyword">this</span>.rejectCallback.push(onReject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>可以认为是<code>Promise</code>的语法糖，也可以认为是<code>Generator</code>的语法糖</p>
<p>注意点：</p>
<ol>
<li><p>没法处理并发的过程(需要<code>Promise.all</code>)</p>
</li>
<li><p>注意以下代码</p>
</li>
</ol>
<p><code>a = a + 10</code>这个<code>a</code>尤其要注意b调用的时候是0，而不是1，只有遇到<code>await</code>才会开启协程与主线程合作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure>

<h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>以下不区分node环境还是浏览器环境</p>
<p>微任务：<code>Promise.then MutationObserver process.nextTick Object.observe</code></p>
<p>宏任务队列：<code>setTimeout setInterval 读写I/O setImmediate UI渲染</code></p>
<p><code>js</code>线程与<code>GUI</code>互斥，可以使用<code>requestAnimationFrame</code>把这两件事情给关联起来, 这个 API 保证在<strong>下次浏览器渲染之前</strong>一定会被调用, 这个是浏览器自己去调节的</p>
<h2 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h2><p>主线程 -&gt; 推入事件表, 注册回调函数（Event Table） -&gt; 主线程执行完毕 -&gt; 微任务队列 -&gt; GUI渲染 -&gt; 宏任务队列(满足条件的执行回调) -&gt; 宏任务对应的微任务</p>
<h2 id="node的事件循环"><a href="#node的事件循环" class="headerlink" title="node的事件循环"></a>node的事件循环</h2><p><img src="Node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt=""></p>
<p>以上各阶段注意点：</p>
<ol>
<li><p><em>timer</em>阶段处理<code>setTimeout setInterval</code>等宏任务</p>
</li>
<li><p><em>poll</em>阶段处理<code>读写I/O</code></p>
</li>
<li><p><em>check</em>阶段处理<code>setImmediate</code></p>
</li>
<li><p><code>setTimeout(() =&gt; { console.log(&#39;setTimeout&#39;);}, 0);</code>和<code>setImmediate</code>到底谁先执行</p>
<ul>
<li>设置为0， 默认为1ms</li>
<li>如果进入<code>eventLoop</code>都不到1ms, 那么触发了回调的条件，优先执行<code>setTimeout</code>，否则执行<code>setImmediate</code></li>
</ul>
</li>
</ol>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>注意以下几点：</p>
<ol>
<li><code>Date</code>对象</li>
<li><code>正则</code>对象</li>
<li>循环引用</li>
<li>原型的拷贝</li>
<li><code>Symbol</code>关键字</li>
<li><code>函数</code></li>
<li>原对象的<code>描述符</code>（可枚举，可写性等等）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isComplexStruct</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">obj, hashMap = new WeakMap</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.constructor === <span class="built_in">Date</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj.constructor === <span class="built_in">RegExp</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hashMap.has(obj))&#123;</span><br><span class="line">        <span class="keyword">return</span> hashMap.get(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> allDes = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), allDes)</span><br><span class="line"></span><br><span class="line">    hashMap.set(obj, cloneObj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj))&#123;</span><br><span class="line">        cloneObj[key] = (isComplexStruct(obj[key]) &amp;&amp; <span class="keyword">typeof</span> obj[key] !== <span class="string">'function'</span>) ? cloneDeep(obj[key], hashMap) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>防抖：事件触发n秒后再执行回调函数，如果期间又被触发，那么重新计时</p>
<p>节流：在特定的时间段只执行一次</p>
<h2 id="手写防抖"><a href="#手写防抖" class="headerlink" title="手写防抖"></a>手写防抖</h2><p>注意点：清空已有的定时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> fn(...rest)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写节流"><a href="#手写节流" class="headerlink" title="手写节流"></a>手写节流</h2><p>注意点：用当前时间作为依据，判断是否在指定的时间区间内</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Date</span>.now() - preTime &gt;= delay)&#123;</span><br><span class="line">            preTime = <span class="built_in">Date</span>.now()</span><br><span class="line">            <span class="keyword">return</span> fn(...rest)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h1><p>数组比较熟悉，主要有个常用的排序算法</p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>思想：抽一个中间值，遍历数组，大的放右边，小的放左边，递归左右数组排序在合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quick = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">const</span> index = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> middleVal = arr.splice(index, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> left = [];</span><br><span class="line">        <span class="keyword">const</span> right = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= middle)&#123;</span><br><span class="line">                left.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; middle)&#123;</span><br><span class="line">                right.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quick(left).concat([middle], quick(right))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quick(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p>柯里化就是将一系列参数转换为一个或者多个参数，多次调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = fn.length</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...rest</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> realLength = args.length + rest.length</span><br><span class="line">        <span class="keyword">if</span>(realLength &lt; length)&#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, ...[...args, ...rest])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, [...args, ...rest])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ErrorBoundary预防白屏</title>
    <url>/2022/04/01/ErrorBoundary%E9%A2%84%E9%98%B2%E7%99%BD%E5%B1%8F/</url>
    <content><![CDATA[<h2 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h2><h3 id="白屏场景："><a href="#白屏场景：" class="headerlink" title="白屏场景："></a>白屏场景：</h3><ul>
<li>前端边缘场景导致的代码错误</li>
<li>沟通没有对称，后端数据结构的突变导致代码层报错</li>
<li>后端部署服务导致的接口不可用进而产生的前端报错<h5 id=""><a href="#" class="headerlink" title=""></a></h5></li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>为了提升用户体验上的友好，增加<code>ErrorBoundary</code>做<code>UI层</code>降级当页面发生报错的时候，用户依然可以点击菜单栏进行模块切换，无需刷新页面或者重新打开路由，防止客户暴躁的情况出现</p>
<h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2><ol>
<li>增加<code>ErrorBoundary</code>组件，用于捕获错误，将其包裹在渲染非导航栏渲染位置</li>
<li>记录报错路由，当用户重新点击其他模块时与错误路由比较，如果不一致，取消错误，重新请求页面</li>
<li>渲染遇到错误时对应需要展示的组件</li>
</ol>
<a id="more"></a>

<h3 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h3><p><strong>ErrorBoundary.jsx</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span>, <span class="attr">pathname</span>: props.location.pathname &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError() &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// 如果路由不相等, 并且是之前有错误的, 取消错误, 重新展示正常的页面</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.history.location.pathname !== nextState.pathname &amp;&amp; <span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line react/no-did-update-set-state</span></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        hasError: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  componentDidCatch(error) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      pathname: <span class="keyword">this</span>.props.location.pathname, <span class="comment">// 设置对应的错误路由</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="comment">// logErrorToMyService(error, errorInfo);</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ErrorUI</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(ErrorBoundary);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li><code>componentDidUpdate</code>中获取最新路由的时候需要从<code>nextProps</code>中路由对象<code>history</code>中获取，而非<code>location</code>，<code>location</code>获取到的并非最新的路由，而且跳转前当前的路由</li>
<li><code>componentDidCatch</code>用户捕获错误，方法可以返回<code>error</code>，可以在其进行错误上报，未来可扩展</li>
</ol>
<p><strong>Layout.jsx</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Layout&gt;</span><br><span class="line">  <span class="comment">// 顶部导航</span></span><br><span class="line">  &lt;Navigation</span><br><span class="line">    collapsed=&#123;collapsed&#125;</span><br><span class="line">    customExtraItem=&#123;customExtraItem&#125;</span><br><span class="line">    customNavigation=&#123;customNavigation&#125;</span><br><span class="line">    logo=&#123;logo&#125;</span><br><span class="line">    pathArr=&#123;pathArr&#125;</span><br><span class="line">    toggleCollapsed=&#123;toggleCollapsed&#125;</span><br><span class="line">    &#123;...navigation&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;Layout className=&#123;styles[<span class="string">'section'</span>]&#125;&gt;</span><br><span class="line">    <span class="comment">// 侧边导航</span></span><br><span class="line">    &#123;</span><br><span class="line">      !noSider &amp;&amp;</span><br><span class="line">        &lt;SideMenu</span><br><span class="line">          collapsed=&#123;collapsed&#125;</span><br><span class="line">          customSideMenu=&#123;customSideMenu&#125;</span><br><span class="line">          customSideMenuItem=&#123;customSideMenuItem&#125;</span><br><span class="line">          getBadgeCount=&#123;getBadgeCount&#125;</span><br><span class="line">          keyMap=&#123;keyMap&#125;</span><br><span class="line">          menu=&#123;menu&#125;</span><br><span class="line">          pathArr=&#123;pathArr&#125;</span><br><span class="line">          toggleCollapsed=&#123;toggleCollapsed&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主体内容</span></span><br><span class="line">    &lt;div className=&#123;styles[<span class="string">'content'</span>]&#125;&gt;</span><br><span class="line">      <span class="comment">// 错误边界包裹位置</span></span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Layout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="ErrorBoundary%E6%95%88%E6%9E%9C.png" alt="ErrorBoundary效果.png"></p>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP(持续更新)</title>
    <url>/2021/09/13/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h1><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p>起始行 + 头部 + 空行 +实体</p>
<p>头部格式特点：</p>
<ol>
<li>不区分大小写</li>
<li>字段名不允许出现空格, 不允许出现<code>_</code></li>
<li>字段名后面需要<strong>紧接着</strong><code>:</code><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2></li>
</ol>
<h3 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h3><ol>
<li>缓存：<code>GET</code>请求的数据会被浏览器缓存，<code>POST</code>不会</li>
<li>编码：<code>GET</code>只能接受<code>ASCII</code>码，<code>POST</code>没有限制</li>
<li>幂等性：<code>GET</code>请求是幂等的，无论多少次，结果是一样的，<code>POST</code>可能会随着次数的不同而不同</li>
<li>参数：<code>GET</code>参数都是放在<code>URL</code>中的，<code>POST</code>是放在<code>body</code>中的</li>
<li>TCP: <code>GET</code>的话是作为一个包发出去的，<code>POST</code>会分成两个包，首先发<code>head</code>,然后发<code>body</code></li>
</ol>
<h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p><img src="URI.jpg" alt=""></p>
<p>组成格式：<br>协议名 + 主机信息 + 主机名:端口 + 资源路径 + 参数 + 锚点</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>1xx: 中间状态，还有后续操作</p>
<ul>
<li>HTTP升级为<code>webSocket</code>，同意变更返回<code>101</code></li>
</ul>
<p>2xx: 成功状态</p>
<ul>
<li>200 最常见的成功</li>
<li>204 和200一样，响应头后没有<code>body</code></li>
<li>206 部分内容，断点续传，需要带上响应头字段<code>Content-Range</code></li>
</ul>
<p>3xx: 原资源位置变动，重定向</p>
<ul>
<li>301 永久重定向(例如：<code>HTTP</code>变更为<code>HTTPS</code>)</li>
<li>302 临时重定向(例如：服务器升级)</li>
<li>304 协商缓存命中</li>
</ul>
<p>4xx: 客户端请求有误</p>
<ul>
<li>400 Bad Request</li>
<li>403 Forbidden 服务端禁止</li>
<li>404 资源没找到</li>
<li>405 请求方法有误</li>
<li>413 请求体数据过大</li>
<li>414 请求行URI过大</li>
</ul>
<p>5xx: 服务端有误</p>
<ul>
<li>500 服务器内部错误</li>
<li>501 客户端请求功能不支持</li>
<li>502 服务端是正常的，但是访问出错(运维比较多)<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2></li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>灵活可扩展</li>
</ol>
<ul>
<li>请求易扩展，保证格式的情况下自定义请求头，请求实体等</li>
<li>传输多样，可以传输文本，照片，视频等等</li>
</ul>
<ol start="2">
<li><p>基于<code>TCP</code>可靠传输</p>
</li>
<li><p>请求——应答模式</p>
</li>
<li><p>无状态，独立无关，不需要保存信息，节省网络开销</p>
</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>无状态，需要大量获取重复信息</p>
</li>
<li><p>明文传输，易被攻击</p>
</li>
</ol>
<h2 id="Accept系列字段"><a href="#Accept系列字段" class="headerlink" title="Accept系列字段"></a>Accept系列字段</h2><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>发送端发送的数据类型用<code>Content-Type</code></p>
<p>想要接收的数据类型用<code>Accept</code></p>
<h3 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h3><p>接收的压缩方式字段<code>Accept-Encoding</code>，值为常见的压缩方式<code>gzip deflate br</code></p>
<h3 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h3><p>接收的语言类型<code>Accept-Language</code></p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>发送端表现在<code>Content-Type</code>, 接收端表现在<code>Accept-Charset</code></p>
<h2 id="定长与不定长数据"><a href="#定长与不定长数据" class="headerlink" title="定长与不定长数据"></a>定长与不定长数据</h2><h3 id="定长"><a href="#定长" class="headerlink" title="定长"></a>定长</h3><p><code>Content-Length</code>字段，只能比响应的短，<strong>不能比响应结果长(会导致传输失败)</strong></p>
<h3 id="不定长"><a href="#不定长" class="headerlink" title="不定长"></a>不定长</h3><p><code>Transfer-Encoding: chunked</code>配合<code>Content-Length</code>进行分段传输，后端会将内容分段传输过来，其中<code>Connection</code>保持<code>keep-alive</code></p>
<h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p><code>Accept-Ranges</code>范围传输</p>
<h3 id="Range-字段拆解"><a href="#Range-字段拆解" class="headerlink" title="Range 字段拆解"></a>Range 字段拆解</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单段数据</span></span><br><span class="line">Range: bytes=0-9</span><br><span class="line"><span class="comment"># 多段数据</span></span><br><span class="line">Range: bytes=0-9, 20-39</span><br></pre></td></tr></table></figure>

<h3 id="多段数据返回"><a href="#多段数据返回" class="headerlink" title="多段数据返回"></a>多段数据返回</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Type: multipart/byteranges; boundary=00000010101</span><br><span class="line">Content-Length: 189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 0-9/96</span><br><span class="line"></span><br><span class="line">i am xxxxx</span><br><span class="line">--00000010101</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Range: bytes 20-29/96</span><br><span class="line"></span><br><span class="line">eex jspy e</span><br><span class="line">--00000010101--</span><br></pre></td></tr></table></figure>

<p>其中<code>Content-Type: multipart/byteranges;boundary=00000010101</code>表示多段数据返回，<code>boundary</code>表示多段数据的分割符</p>
<h2 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h2><p>主要通过<code>Content-Type</code>决定表单数据的格式</p>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>会编码成<code>&amp;</code>分隔的键值对, 以<strong>URL</strong>的方式编码</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>请求头包含<code>boundary</code>，浏览器决定。<strong>每一个表单元素都是独立的资源表述</strong></p>
<h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><h3 id="概念和原因"><a href="#概念和原因" class="headerlink" title="概念和原因"></a>概念和原因</h3><p>同一个<code>TCP</code>长连接，队首请求阻塞导致后面的请求没有正常执行</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>域名分片，使用多个二级域名减轻<code>http</code>的压力</li>
<li>1.x版本使用并发连接，一次可以连接<code>6个http请求(chrome)</code></li>
<li><code>HTTP/2</code>使用了多路复用，采用二进制分帧，将头部信息和实体数据分别采用二进制形式传输，同一个连接的请求是有序的。<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2></li>
</ol>
<p><code>Cookie</code>是保存会话状态的方式，服务端可用<code>Set-Cookie</code>来对客户端写入</p>
<h3 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h3><p><code>Expire</code>: 存放过期时间</p>
<p><code>Max-Age</code>: <strong>单位是秒</strong>，存放可保存的时间</p>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p><code>Domain</code>: 只在当前域名下生效</p>
<p><code>Path</code>: 当前域名的指定路径下生效</p>
<h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p><code>Secure</code>: 只能通过<code>HTTPS</code>来传输<code>Cookie</code></p>
<p><code>SameSite</code>: <code>Strict</code>表示只有同源才能传输，<code>Lax</code>只有<code>get</code>请求才能传输，<code>None</code>没有限制</p>
<p><code>HttpOnly</code>: 只能传输，不能通过<code>js</code>访问，可以预防<code>XSS</code>攻击</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>代理客户端，服务器不知道发起请求的是哪个客户端(例如：VPN)</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>代理服务端，客户端不知道响应请求的是哪个服务器(例如：负载均衡)</p>
<h3 id="Via字段"><a href="#Via字段" class="headerlink" title="Via字段"></a>Via字段</h3><p>服务端收到的请求头上会带有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">via: proxy-server1 proxy-server2</span><br></pre></td></tr></table></figure>

<p>客户端收到的响应头上会带有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">via: proxy-server2 proxy-server1</span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>具体看<a href="https://auglyxu.github.io/2022/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%AB%E8%82%A1%E6%96%87/">浏览器八股文</a></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ol>
<li><code>Expire</code>字段设置请求时间并发送给服务器，服务器根据此字段给出的时间决定返回内容</li>
<li><code>Cache-Control</code> + <code>max-age</code>控制，<code>private</code>表示不允许代理服务器缓存。<code>public</code>表示允许代理服务器缓存，<code>max-age</code>表示缓存时间</li>
</ol>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><ol>
<li><code>if-modified-since</code>和<code>last-modified</code>，根据文件最后修改时间判断是否是缓存中拿，缺陷就是修改文件可能前后一致，但是时间不一致，或者说本地时间和服务器时间可能有偏差，缓存都会失效，因此也有可能会采用下面2的形式。</li>
<li><code>if-none-match</code>和<code>Etag</code>，根据文件内容生成<code>hash</code>来确定，缺点就是消耗服务器资源，并且不同的服务器生成的<code>hash</code>也可能不一样。<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2></li>
</ol>
<p><strong>协议+主机+端口三者有一个不一致</strong>称为跨域</p>
<p>通常请求是由浏览器<strong>渲染进程</strong>创建的，<strong>网络进程</strong>发起的，拦截是由<strong>主进程</strong>拦截的，这里涉及到了进程的通信，利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 <code>IPC</code> 过程</p>
<h3 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h3><p>服务端<code>Access-Control-Allow-Origin</code>确认了允许跨域的源<br>服务端<code>Access-Control-Allow-Credentials</code>确认了<code>Cookie</code>是否允许跨域，同时客户端<code>withCredentials = true</code>保证了可以跨域</p>
<h3 id="非简单请求的跨域"><a href="#非简单请求的跨域" class="headerlink" title="非简单请求的跨域"></a>非简单请求的跨域</h3><p>非简单请求会发预检请求，预检请求会拿到一系列<code>Access-Control-xxx</code>的字段，浏览器主进程会根据这些字段进行拦截</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>利用<code>script</code>标签没有跨域限制，缺点是只能发<code>get</code>请求</p>
<p>实现方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generateUrl = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> requestUrl = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">let</span> callbackName = callbackName || <span class="built_in">Math</span>.random().toString().replace(<span class="string">','</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params)&#123;</span><br><span class="line">            requestUrl += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        requestUrl += <span class="string">`<span class="subst">$&#123;callback&#125;</span>=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;requestUrl&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">'sctipt'</span>)</span><br><span class="line">        scriptEle.src = generateUrl();</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(scriptEle)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><h3 id="握手流程"><a href="#握手流程" class="headerlink" title="握手流程"></a>握手流程</h3><ol>
<li>客户端生成随机数<code>client_random</code>、<code>加密方式</code>、<code>TLS</code>版本传给服务端</li>
<li>服务端生成<code>server_random</code>、拿到<code>数字证书</code>传给客户端</li>
<li>客户端验证数字证书，并用 <strong>数字证书的公钥加密会话的密钥(对称加密的密钥)</strong> 传给后端</li>
<li>后端用数字证书的私钥对<code>密钥</code>进行解密，拿这个<code>密钥</code>进行对称加密沟通</li>
</ol>
<h3 id="断开重连"><a href="#断开重连" class="headerlink" title="断开重连"></a>断开重连</h3><p><code>Session ID</code>每个服务器针对每次会话都有一个<code>id</code>，但是不同服务器<code>id</code>可能不一样。</p>
<p><code>Session ticket</code>服务器加密完成之后返给客户端的，发到其他服务器上的时候就可以根据这个<code>ticket</code>获取信息。</p>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>采用二进制分帧，解决了队头阻塞的问题。</p>
<p>二进制分帧，将数据转换为二级制，保存在头部和实体中，通过流ID来保证请求的一致性，并且可以是双向的</p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>头部压缩，减少网络传输数据量</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>React-commit阶段</title>
    <url>/2022/06/24/React-commit%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="React-commit阶段"><a href="#React-commit阶段" class="headerlink" title="React-commit阶段"></a>React-commit阶段</h1><p><code>React-render</code>阶段，当组件发生更新的时候，<code>beginWork</code>先为更新的组件打上了<code>flag</code>，</p>
<p>Todo</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2020/08/02/Redux/</url>
    <content><![CDATA[<p>本文默认会使用基本的Redux, 主要对自己学习Redux中一些比较困难的点进行思考和学习.</p>
<h2 id="Redux阅读和使用上遇到的一些难点"><a href="#Redux阅读和使用上遇到的一些难点" class="headerlink" title="Redux阅读和使用上遇到的一些难点"></a>Redux阅读和使用上遇到的一些难点</h2><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><h2 id="实现一个简易的Redux"><a href="#实现一个简易的Redux" class="headerlink" title="实现一个简易的Redux"></a>实现一个简易的Redux</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><h3 id="middleWare"><a href="#middleWare" class="headerlink" title="middleWare"></a>middleWare</h3><h2 id="React-Redux-Hooks"><a href="#React-Redux-Hooks" class="headerlink" title="React-Redux Hooks"></a>React-Redux Hooks</h2><h3 id="useStore"><a href="#useStore" class="headerlink" title="useStore"></a>useStore</h3><h3 id="useSelect"><a href="#useSelect" class="headerlink" title="useSelect"></a>useSelect</h3><h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch"></a>useDispatch</h3>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React-render阶段(二)</title>
    <url>/2021/06/12/React-render%E9%98%B6%E6%AE%B5%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="React-render阶段-二"><a href="#React-render阶段-二" class="headerlink" title="React-render阶段(二)"></a>React-render阶段(二)</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>React-render阶段一</code>解释了当组件进入<code>reconciler</code>后的执行过程, 从<code>root</code>节点开始调度, 循环调用<code>beginWork</code>创建子节点. 其中创建子节点的过程又分为挂载阶段和更新阶段, 挂载阶段不追踪副作用, 更新阶段追踪副作用, 更新阶段又分为可复用和不可复用, 可复用的会进入<code>bailout</code>的复用逻辑, 会把<code>current</code>树中的当前节点以及其子节点复制到<code>workInProgress</code>树中, 没有进入<code>bailout</code>阶段的<code>Fiber</code>节点会进入<code>diff</code>算法(对应的<code>current</code>中的<code>Fiber</code>节点与返回的<code>JSX</code>对比, 生成新的<code>Fiber</code>节点), 并为新的<code>Fiber</code>节点打上<code>effectTag</code></p>
<p>当前<code>Fiber</code>节点没有子节点时就进入了<code>completeWork</code>, 可以理解为递归阶段的归阶段, <code>completeWork</code>的目的就是为了创建好对应的<code>dom</code>节点插入对应的父级节点的<code>dom</code>节点, 为其添加副作用标识, 再<code>commit</code>阶段将对应的节点展示到页面上并执行对应的副作用.</p>
<p>以下我以<code>cra</code>创建的项目的代码举例, js如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">        &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">        &lt;p onClick=&#123;() =&gt; &#123; setNum(num + <span class="number">1</span>) &#125;&#125;&gt;</span><br><span class="line">          &#123;num&#125; &lt;code&gt;src/App.js&lt;<span class="regexp">/code&gt; and save to reload.</span></span><br><span class="line"><span class="regexp">        &lt;/</span>p&gt;</span><br><span class="line">        &lt;a</span><br><span class="line">          className=<span class="string">"App-link"</span></span><br><span class="line">          href=<span class="string">"https://reactjs.org"</span></span><br><span class="line">          target=<span class="string">"_blank"</span></span><br><span class="line">          rel=<span class="string">"noopener noreferrer"</span></span><br><span class="line">        &gt;</span><br><span class="line">          Learn React</span><br><span class="line">        &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>header&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="CompleteWork执行时机与分析"><a href="#CompleteWork执行时机与分析" class="headerlink" title="CompleteWork执行时机与分析"></a>CompleteWork执行时机与分析</h3><p><code>completeWork</code>发生在当前<code>Fiber</code>节点没有子节点的情况下, 源码发生在<code>performUnitOfWork</code>函数中, 这个函数发生在上文提到过的<code>workLoopSync</code>中, 这个函数将被循环调用<br><img src="completeWork%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6.png" alt=""><br>上图打了两个断点处就是completeWork是否执行的条件, 第一个断点拿到的是<code>beginWork</code>创建好的子<code>Fiber</code>节点, 如果没有子<code>Fiber</code>节点则返回<code>null</code>, 只有当<code>next</code>为<code>null</code>的时候才会进入<code>completeWork</code>, <code>completeWork</code>的开始源于他的上层函数<code>completeUnitOfWork</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> completedWork = unitOfWork; <span class="comment">// 获取当前completeWork的Fiber节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = completedWork.alternate; <span class="comment">// 获取当前completeWork对应的current树上的节点, 没有则表示是新增的节点</span></span><br><span class="line">    <span class="keyword">var</span> returnFiber = completedWork.return; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((completedWork.flags &amp; Incomplete) === NoFlags) &#123;</span><br><span class="line">      setCurrentFiber(completedWork);</span><br><span class="line">      <span class="keyword">var</span> next = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( (completedWork.mode &amp; ProfileMode) === NoMode) &#123;</span><br><span class="line">        next = completeWork(current, completedWork, subtreeRenderLanes);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startProfilerTimer(completedWork);</span><br><span class="line">        next = completeWork(current, completedWork, subtreeRenderLanes); <span class="comment">// Update render duration assuming we didn't error.</span></span><br><span class="line"></span><br><span class="line">        stopProfilerTimerIfRunningAndRecordDelta(completedWork, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      resetCurrentFiber();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        workInProgress = next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> _next = unwindWork(completedWork, subtreeRenderLanes); <span class="comment">// Because this fiber did not complete, don't reset its expiration time.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        _next.flags &amp;= HostEffectMask;</span><br><span class="line">        workInProgress = _next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">        stopProfilerTimerIfRunningAndRecordDelta(completedWork, <span class="literal">false</span>); <span class="comment">// Include the time spent working on failed children before continuing.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">        <span class="keyword">var</span> child = completedWork.child;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">          actualDuration += child.actualDuration;</span><br><span class="line">          child = child.sibling;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        completedWork.actualDuration = actualDuration;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (returnFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">        returnFiber.flags |= Incomplete;</span><br><span class="line">        returnFiber.subtreeFlags = NoFlags;</span><br><span class="line">        returnFiber.deletions = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> siblingFiber = completedWork.sibling;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there is more work to do in this returnFiber, do that next.</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">// Otherwise, return to the parent</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    completedWork = returnFiber; <span class="comment">// Update the next thing we're working on in case something throws.</span></span><br><span class="line"></span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>); <span class="comment">// We've reached the root.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === RootIncomplete) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>completeUnitOfWork</code>从源码中可以看到是一个<code>do while</code>循环, 终止条件有<code>completeWork !== null</code>或者循环内<code>return</code>前的几个终止条件, 我们可以看到有一个是<code>siblingFiber</code>不为<code>null</code>的情况. 即当前的节点存在兄弟节点时并且已经没有子节点, 当前节点会结束<code>completeWork</code>, 跳出调用栈, 执行下一次循环, 进入兄弟节点的<code>beginWork</code>.当兄弟节点为<code>null</code>的时候, 那么<code>completeWork</code>会被赋值为<code>returnFiber</code>, 这个时候注意并没有用<code>return</code>跳出调用栈, 因为父级节点的<code>beginWork</code>已经被执行, 因此会进入父级节点的<code>completeWork</code>, 由此向上, 当<code>completeWork</code>为<code>null</code>时意味着归到根节点</p>
<p>接下来分析一下<code>completeWork</code>做的具体的事情</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'completeWork'</span>, <span class="string">'tag:'</span>, workInProgress.tag, <span class="string">' type:'</span>, workInProgress.type);</span><br><span class="line">  <span class="keyword">var</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> Component = workInProgress.type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isContextProvider(Component)) &#123;</span><br><span class="line">          popContext(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bubbleProperties(workInProgress);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        popHostContext(workInProgress);</span><br><span class="line">        <span class="keyword">var</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">        <span class="keyword">var</span> type = workInProgress.type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">          updateHostComponent$<span class="number">1</span>(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">            markRef$<span class="number">1</span>(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(workInProgress.stateNode !== <span class="literal">null</span>)) &#123;</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span> );</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="comment">// This can happen when we abort work.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            bubbleProperties(workInProgress);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> currentHostContext = getHostContext(); <span class="comment">// <span class="doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span></span><br><span class="line">          <span class="comment">// "stack" as the parent. Then append children as we go in beginWork</span></span><br><span class="line">          <span class="comment">// or completeWork depending on whether we want to add them top-&gt;down or</span></span><br><span class="line">          <span class="comment">// bottom-&gt;up. Top-&gt;down is faster in IE11.</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> _wasHydrated = popHydrationState(workInProgress);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (_wasHydrated) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Move this and createInstance step into the beginPhase</span></span><br><span class="line">            <span class="comment">// to consolidate.</span></span><br><span class="line">            <span class="keyword">if</span> (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123;</span><br><span class="line">              <span class="comment">// If changes to the hydrated node need to be applied at the</span></span><br><span class="line">              <span class="comment">// commit-phase we mark this as such.</span></span><br><span class="line">              markUpdate(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line">            appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            workInProgress.stateNode = instance; <span class="comment">// Certain renderers require commit-time effects for initial mount.</span></span><br><span class="line">            <span class="comment">// (eg DOM renderer supports auto-focus for certain elements).</span></span><br><span class="line">            <span class="comment">// Make sure such renderers get scheduled for later work.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line">              markUpdate(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (workInProgress.ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a ref on a host node we need to schedule a callback</span></span><br><span class="line">            markRef$<span class="number">1</span>(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bubbleProperties(workInProgress);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...以下省略的是针对其他组件的执行逻辑, 这里我们重点关注前几个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中看到<code>completeWork</code>函数就是针对不同的<code>Fiber</code>节点的<code>Tag</code>, 处理不同的逻辑, 我们根据<code>p</code>标签为例, 会进入<code>case</code>为<code>HostComponent</code>的分支</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// completeWork顺序如下(展示一部分, 归到p标签为止)</span></span><br><span class="line"><span class="number">1.</span> img</span><br><span class="line"><span class="number">2.</span> &#123;num&#125;</span><br><span class="line"><span class="number">3.</span> num后面的空格</span><br><span class="line"><span class="number">4.</span> code</span><br><span class="line"><span class="number">5.</span>  and save to reload.</span><br><span class="line"><span class="number">6.</span> p</span><br></pre></td></tr></table></figure>
<p><img src="completeWork%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt=""></p>
<h4 id="mount阶段"><a href="#mount阶段" class="headerlink" title="mount阶段"></a>mount阶段</h4><p>根据上面的<code>completeWork</code>的分析, 我们直接看上面 <code>HostComponent</code> 的逻辑, 一行一行看<br>开始的逻辑都是一样的, 首先处理<code>context</code>, 获取根容器</p>
<ol>
<li><code>popHostContext</code>是和<code>context</code>相关的逻辑, 暂时跳过</li>
<li><code>rootContainerInstance</code>是获取根容器<code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code><br>接下来的逻辑会根据挂载和更新进入不同的条件语句, 重新贴一下核心代码<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">    updateHostComponent$<span class="number">1</span>(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">    markRef$<span class="number">1</span>(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newProps) &#123; <span class="comment">// 如果没有新的props并且stateNode为null, 可能是React发生了内部错误, 挂载时newProps至少也是一个&#123;&#125;, 一定不会进这里</span></span><br><span class="line">        <span class="keyword">if</span> (!(workInProgress.stateNode !== <span class="literal">null</span>)) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">        bubbleProperties(workInProgress);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> currentHostContext = getHostContext(); <span class="comment">// context相关</span></span><br><span class="line">    <span class="keyword">var</span> _wasHydrated = popHydrationState(workInProgress); <span class="comment">// 服务端渲染相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_wasHydrated) &#123;<span class="comment">// 服务端渲染</span></span><br><span class="line">        <span class="keyword">if</span> (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123;</span><br><span class="line">            </span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line">        appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        workInProgress.stateNode = instance; <span class="comment">// Certain renderers require commit-time effects for initial mount.</span></span><br><span class="line">        <span class="comment">// (eg DOM renderer supports auto-focus for certain elements).</span></span><br><span class="line">        <span class="comment">// Make sure such renderers get scheduled for later work.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line">                markUpdate(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgress.ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a ref on a host node we need to schedule a callback</span></span><br><span class="line">            markRef$<span class="number">1</span>(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
跳过<code>context</code>相关和服务端渲染相关, 会进入 <code>instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress)</code>, 这里主要是创建<code>dom</code>实例, 进去看下这个函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parentNamespace;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> hostContextDev = hostContext;</span><br><span class="line">    <span class="comment">// 检测dom是否正确嵌套</span></span><br><span class="line">    validateDOMNesting(type, <span class="literal">null</span>, hostContextDev.ancestorInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> props.children === <span class="string">'string'</span> || <span class="keyword">typeof</span> props.children === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> string = <span class="string">''</span> + props.children;</span><br><span class="line">      <span class="keyword">var</span> ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);</span><br><span class="line">      validateDOMNesting(<span class="literal">null</span>, string, ownAncestorInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parentNamespace = hostContextDev.namespace;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建dom实例</span></span><br><span class="line">  <span class="keyword">var</span> domElement = createElement(type, props, rootContainerInstance, parentNamespace);</span><br><span class="line">  <span class="comment">// 缓存这个fiber节点</span></span><br><span class="line">  precacheFiberNode(internalInstanceHandle, domElement);</span><br><span class="line">  <span class="comment">// 更新fiber节点的props, react会自己定义一个值, 所有的props将存放在当前的dom实例上</span></span><br><span class="line">  updateFiberProps(domElement, props);</span><br><span class="line">  <span class="keyword">return</span> domElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
返回创建好的<code>domElement</code>, 然后直接插入逻辑, 对应的代码为<code>appendAllChildren(instance, workInProgress, false, false);</code>, 看下这个函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendAllChildren = <span class="function"><span class="keyword">function</span> (<span class="params">parent, workInProgress, needsVisibilityToggle, isHidden</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到当前工作单元的child Fiber节点, 即拿到第一个子节点</span></span><br><span class="line">    <span class="keyword">var</span> node = workInProgress.child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.tag === HostComponent || node.tag === HostText) &#123; <span class="comment">// 如果是文本节点或者是原生dom节点</span></span><br><span class="line">            <span class="comment">// 这个函数调用的就是parent.appendChild(node.stateNode);</span></span><br><span class="line">            appendInitialChild(parent, node.stateNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.tag === HostPortal) ; <span class="keyword">else</span> <span class="keyword">if</span> (node.child !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node.child.return = node;</span><br><span class="line">            node = node.child;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node === workInProgress) &#123; <span class="comment">// 如果是当前工作单元, 插入完毕</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node.sibling === <span class="literal">null</span>) &#123; <span class="comment">// 没有兄弟节点则Fiber向上冒泡</span></span><br><span class="line">            <span class="keyword">if</span> (node.return === <span class="literal">null</span> || node.return === workInProgress) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.sibling.return = node.return; <span class="comment">// 把兄弟节点的return节点赋值给父节点</span></span><br><span class="line">        node = node.sibling; <span class="comment">// 把node赋值为兄弟节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<code>appendAllChildren</code>的作用和函数名相同, 目的就是把当前工作单元的所有子节点全部插入到刚创建好的<code>dom实例</code>中, 全部插入完毕执行<code>workInProgress.stateNode = instance;</code>, 这里采用的是深度优先遍历的方式<br>此时这里的<code>instance</code>为插入完的<code>dom</code>实例, 并把对应的节点赋值到当前<code>Fiber</code>节点的<code>stateNode</code>上<br><img src="%E6%8F%92%E5%85%A5%E5%AE%8C%E7%9A%84dom%E5%AE%9E%E4%BE%8B.png" alt=""></li>
</ol>
<p>然后执行的是<code>finalizeInitialChildren</code>方法, 此方法调用了<code>setInitialProperties</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInitialProperties</span>(<span class="params">domElement, tag, rawProps, rootContainerElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isCustomComponentTag = isCustomComponent(tag, rawProps);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    validatePropertiesInDevelopment(tag, rawProps);</span><br><span class="line">  &#125; <span class="comment">// <span class="doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="comment">// 跳过一些dom节点的判断逻辑</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      props = rawProps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断props是否合法</span></span><br><span class="line">  assertValidProps(tag, props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置初始化的dom属性</span></span><br><span class="line">  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">      track(domElement);</span><br><span class="line">      postMountWrapper(domElement, rawProps, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'textarea'</span>:</span><br><span class="line">      track(domElement);</span><br><span class="line">      postMountWrapper$<span class="number">3</span>(domElement);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'option'</span>:</span><br><span class="line">      postMountWrapper$<span class="number">1</span>(domElement, rawProps);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">      postMountWrapper$<span class="number">2</span>(domElement, rawProps);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> props.onClick === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This cast may not be sound for SVG, MathML or custom elements.</span></span><br><span class="line">        trapClickOnNonInteractiveElement(domElement);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数主要是判断了<code>props</code>是否合法, 并对特殊的<code>dom</code>节点做了一些操作, 并把初始化的属性赋值到当前的<code>dom</code>上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInitialDOMProperties</span>(<span class="params">tag, domElement, rootContainerElement, nextProps, isCustomComponentTag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextProps.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123; <span class="comment">// style的时候</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">          <span class="built_in">Object</span>.freeze(nextProp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      setValueForStyles(domElement, nextProp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123; <span class="comment">// dangerouslySetInnerHTML</span></span><br><span class="line">      <span class="keyword">var</span> nextHtml = nextProp ? nextProp[HTML$<span class="number">1</span>] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">        setInnerHTML(domElement, nextHtml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123; <span class="comment">// children</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">'string'</span>) &#123;  <span class="comment">// 如果节点是字符串</span></span><br><span class="line">        <span class="keyword">var</span> canSetTextContent = tag !== <span class="string">'textarea'</span> || nextProp !== <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canSetTextContent) &#123;</span><br><span class="line">          setTextContent(domElement, nextProp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">'number'</span>) &#123; <span class="comment">// 如果是数字就转换为字符串</span></span><br><span class="line">        setTextContent(domElement, <span class="string">''</span> + nextProp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === AUTOFOCUS) ; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameDependencies.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> nextProp !== <span class="string">'function'</span>) &#123;</span><br><span class="line">          warnForInvalidEventListener(propKey, nextProp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propKey === <span class="string">'onScroll'</span>) &#123;</span><br><span class="line">          listenToNonDelegatedEvent(<span class="string">'scroll'</span>, domElement);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制初始化的<code>props</code>是调用了<code>setInitialDOMProperties</code>, 这个函数循环调用了新的<code>props</code>, 并对每个<code>propKey</code>做了特定的赋值操作, 这一步主要在<code>setValueForProperty</code>中, 这一步会调用<code>node.setAttribute</code>来为创建好的<code>dom</code>元素设置属性</p>
<p>继续走下去进行的是判断是否存在<code>ref</code>, 如果存在<code>ref</code>则调用<code>markRef$1(workInProgress);</code>函数</p>
<p>最后执行<code>bubbleProperties</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">      <span class="keyword">var</span> actualDuration = completedWork.actualDuration;</span><br><span class="line">      <span class="keyword">var</span> treeBaseDuration = completedWork.selfBaseDuration;</span><br><span class="line">      <span class="keyword">var</span> child = completedWork.child;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));</span><br><span class="line">        subtreeFlags |= child.subtreeFlags;</span><br><span class="line">        subtreeFlags |= child.flags;</span><br><span class="line"></span><br><span class="line">        actualDuration += child.actualDuration;</span><br><span class="line">        treeBaseDuration += child.treeBaseDuration;</span><br><span class="line">        child = child.sibling;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      completedWork.actualDuration = actualDuration;</span><br><span class="line">      completedWork.treeBaseDuration = treeBaseDuration;</span><br></pre></td></tr></table></figure>
<p><code>bubbleProperties</code> 根据<code>fiber.child</code>及<code>fiber.child.sibling</code>更新<code>subtreeFlags</code>和<code>childLanes</code>, 主要是为了标记子树有没有更新, 这样可以通过 <code>fiber.subtreeFlags</code> 快速判断子树是否有副作用钩子，不需要深度遍历. 在<code>React17版本后</code>使用<code>subtreeFlags</code>替换了<code>finishWork.firstEffect</code>的副作用链表, 操作主要发生在<code>bubbleProperties</code>函数中, 核心代码如下</p>
<h4 id="update阶段"><a href="#update阶段" class="headerlink" title="update阶段"></a>update阶段</h4><p>当进入<code>update</code>阶段, 假如我们把<code>p</code>节点的<code>Fiber</code>作为案例, 对应case为<code>HostComponent</code>会进入以下的条件分支</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">    updateHostComponent$<span class="number">1</span>(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">        markRef$<span class="number">1</span>(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateHostComponent$1代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateHostComponent$<span class="number">1</span> = <span class="function"><span class="keyword">function</span> (<span class="params">current, workInProgress, type, newProps, rootContainerInstance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldProps = current.memoizedProps; <span class="comment">// 此状态为更新, 获取current的props</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps === newProps) &#123; <span class="comment">// 判断props是否相同, 相同表示进入了bailout阶段,哪怕children变了我们也不需要做什么操作,因此直接跳过</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> instance = workInProgress.stateNode; <span class="comment">// 获取实例</span></span><br><span class="line">    <span class="keyword">var</span> currentHostContext = getHostContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);</span><br><span class="line"></span><br><span class="line">    workInProgress.updateQueue = updatePayload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (updatePayload) &#123;</span><br><span class="line">      <span class="comment">// 标记更新, 内部直接设置workInProgress.flags |= Update</span></span><br><span class="line">      markUpdate(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>这里调用了一个主要的更新方法为<code>prepareUpdate</code>, 返回的<code>updatePayload</code>将被加入工作单元的更新队列中, 这个函数调用了<code>diffProperties</code>, 其中返回的<code>updatePayload</code>是一个数组, 第i项是对应的<code>propKey</code>, 第<code>i + 1</code>项是对应的<code>value</code>, 当存在<code>updatePayload</code>的时候意味着这个<code>HostComponent</code>存在增,或者更新的情况, 会调用<code>markUpdate</code>进行更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProperties</span>(<span class="params">domElement, tag, lastRawProps, nextRawProps, rootContainerElement</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    validatePropertiesInDevelopment(tag, nextRawProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> updatePayload = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> lastProps;</span><br><span class="line">  <span class="keyword">var</span> nextProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">    <span class="comment">// 这里省略了对特性的dom标签比如(input, select等)赋值lastProps和nextProps的过程</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      lastProps = lastRawProps;</span><br><span class="line">      nextProps = nextRawProps;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> lastProps.onClick !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> nextProps.onClick === <span class="string">'function'</span>) &#123;</span><br><span class="line">        trapClickOnNonInteractiveElement(domElement);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检验props</span></span><br><span class="line">  assertValidProps(tag, nextProps);</span><br><span class="line">  <span class="keyword">var</span> propKey;</span><br><span class="line">  <span class="keyword">var</span> styleName;</span><br><span class="line">  <span class="keyword">var</span> styleUpdates = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="comment">// 针对删除的情况, 需要标记对应的propKey为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastStyle = lastProps[propKey];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.hasOwnProperty(styleName)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">            styleUpdates = &#123;&#125;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === AUTOFOCUS) ; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameDependencies.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!updatePayload) &#123;</span><br><span class="line">        updatePayload = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (updatePayload = updatePayload || []).push(propKey, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">var</span> lastProp = lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 针对新增或者更新的情况, 需要标记对应的propKey为null</span></span><br><span class="line">    <span class="keyword">if</span> (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>) &#123; <span class="comment">// 对应props被删除的情况</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">          <span class="built_in">Object</span>.freeze(nextProp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">        <span class="comment">// 在 `lastProp` 上取消设置样式，但不在 `nextProp` 上设置.</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// 从lastProps中的style更新数据.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">              styleUpdates = &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!styleUpdates) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!updatePayload) &#123;</span><br><span class="line">            updatePayload = [];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          updatePayload.push(propKey, styleUpdates);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        styleUpdates = nextProp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">      <span class="keyword">var</span> nextHtml = nextProp ? nextProp[HTML$<span class="number">1</span>] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">var</span> lastHtml = lastProp ? lastProp[HTML$<span class="number">1</span>] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastHtml !== nextHtml) &#123;</span><br><span class="line">          (updatePayload = updatePayload || []).push(propKey, nextHtml);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">'string'</span> || <span class="keyword">typeof</span> nextProp === <span class="string">'number'</span>) &#123;</span><br><span class="line">        (updatePayload = updatePayload || []).push(propKey, <span class="string">''</span> + nextProp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; <span class="keyword">else</span> <span class="keyword">if</span> (registrationNameDependencies.hasOwnProperty(propKey)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> nextProp !== <span class="string">'function'</span>) &#123;</span><br><span class="line">          warnForInvalidEventListener(propKey, nextProp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (propKey === <span class="string">'onScroll'</span>) &#123;</span><br><span class="line">          listenToNonDelegatedEvent(<span class="string">'scroll'</span>, domElement);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!updatePayload &amp;&amp; lastProp !== nextProp) &#123;</span><br><span class="line">        updatePayload = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> nextProp === <span class="string">'object'</span> &amp;&amp; nextProp !== <span class="literal">null</span> &amp;&amp; nextProp.$$<span class="keyword">typeof</span> === REACT_OPAQUE_ID_TYPE) &#123;</span><br><span class="line">      nextProp.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (updatePayload = updatePayload || []).push(propKey, nextProp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (styleUpdates) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> updatePayload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完这个<code>diffProperties</code>, 再执行<code>bubbleProperties(workInProgress)</code>, 然后就结束了当前节点的<code>completeWork</code></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li><code>Fiber</code>的<code>tag</code>为<code>function</code>的时候是不会进入<code>completeWork</code>的</li>
<li>挂载的时候插入的<code>dom</code>节点的获取方式在于完成的<code>finishedWork</code>, 在<code>performSyncWorkOnRoot</code>函数中</li>
<li><code>React17之前</code>原本有一根<code>finishWork.firstEffect</code>开始的副作用链表, 始终指向的是第一个产生副作用的链表, 链表的<code>nextEffect</code>指向的是下一个具有副作用的链表, 这根链表在<code>React17版本后</code>使用<code>subtreeFlags</code>替换了, 操作主要发生在<code>bubbleProperties</code>函数中</li>
</ol>
<h2 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h2><p>这里梳理一下上述所说的全流程</p>
<p><img src="React-render%E5%BD%92%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png" alt=""></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>lerna包管理</title>
    <url>/2022/09/18/lerna%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="lerna包管理"><a href="#lerna包管理" class="headerlink" title="lerna包管理"></a>lerna包管理</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>目前项目使用<code>lerna</code>来进行包管理，已经停止维护</p>
<p>除了<code>lerna</code>以外，<code>Rush</code>也是一个非常不错的工具，<code>lerna</code>的停止维护目前看来是利好<code>Rush</code>的</p>
<p><code>lerna</code>和<code>Rush</code>解决的都是采用<code>monorepo</code>管理模式的项目</p>
<blockquote>
<p><code>monorepo</code>管理模式：<code>monorepo</code>是一种将多个<code>package</code>放在一个<code>repo</code>中的代码管理模式，摒弃了传统的多个<code>package</code>多个<code>repo</code>的模式</p>
</blockquote>
<h3 id="解决的问题："><a href="#解决的问题：" class="headerlink" title="解决的问题："></a>解决的问题：</h3><ul>
<li>多个包多个项目难以维护和发布</li>
<li>模块的升级需要手动修改包信息</li>
<li>公用<code>npm</code>包的<code>node_modules</code>占用大量空间</li>
</ul>
<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题:"></a>带来的问题:</h3><ul>
<li>单包的权限控制无法实现</li>
<li>单项目过大的体积</li>
</ul>
<h3 id="使用lerna管理的包"><a href="#使用lerna管理的包" class="headerlink" title="使用lerna管理的包"></a>使用lerna管理的包</h3><p>目前<code>Babel, React, Angular, Ember, Meteor, Jest</code>等许多开源项目都使用该种模式来管理代码。</p>
<h2 id="lerna基本使用"><a href="#lerna基本使用" class="headerlink" title="lerna基本使用"></a>lerna基本使用</h2><p><a href="https://www.lernajs.cn/" target="_blank" rel="noopener">官方文档</a></p>
<p>官网过于简单，结合了几篇教程以及自己的实践结果来搭一个较为完整的<code>monorepo</code></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm install lerna -g</code></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h4><p>在自己的<code>github repositories</code>中提前创建了一个空文件夹，并<code>clone</code>下来</p>
<h4 id="初始化lerna"><a href="#初始化lerna" class="headerlink" title="初始化lerna"></a>初始化lerna</h4><p>对应文件目录下执行<code>lerna init</code>, 对应生成两个文件一个文件夹</p>
<p>根目录的<code>lerna.json</code>可以用来配置一些全局性的东西，比如<code>npmClient</code>，项目使用<code>yarn</code>，这里就给他配置为<code>yarn</code>，<code>pnpm</code>也是支持的，只需要正确配置包即可</p>
<p>lerna.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"node_modules/lerna/schemas/lerna-schema.json"</span>, <span class="comment">// IDE 或其它工具将会根据目标地址中的 schema 定义对 JSON 文件进行检查和智能提示等等</span></span><br><span class="line">  <span class="attr">"useNx"</span>: <span class="literal">true</span>, <span class="comment">// 搭配Nx使用</span></span><br><span class="line">  <span class="attr">"useWorkspaces"</span>: <span class="literal">true</span>, <span class="comment">// 使用 Workspaces</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">"npmClient"</span>: <span class="string">"yarn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>package.json</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"root"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>, <span class="comment">// 主包不发布</span></span><br><span class="line">  <span class="string">"workspaces"</span>: [ <span class="comment">// 工作区范围</span></span><br><span class="line">    <span class="string">"packages/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"lerna"</span>: <span class="string">"^5.5.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建工具包"><a href="#创建工具包" class="headerlink" title="创建工具包"></a>创建工具包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna create public-package</span><br></pre></td></tr></table></figure>
<h4 id="命令执行结果"><a href="#命令执行结果" class="headerlink" title="命令执行结果"></a>命令执行结果</h4><p><img src="%E5%88%9B%E5%BB%BA%E6%96%B0%E5%8C%85.png" alt=""></p>
<h4 id="代码结果"><a href="#代码结果" class="headerlink" title="代码结果"></a>代码结果</h4><p><img src="%E5%88%9B%E5%BB%BA%E6%96%B0%E5%8C%85%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>根目录下执行，即可查看自己创建的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna list</span><br></pre></td></tr></table></figure>
<p><img src="%E6%9F%A5%E7%9C%8B%E5%8C%85.png" alt=""></p>
<h2 id="创建-导入项目"><a href="#创建-导入项目" class="headerlink" title="创建/导入项目"></a>创建/导入项目</h2><p>注意：导入和创建项目不会被计入<code>lerna</code>的包，即<code>lerna list</code>不会记录创建或导入的项目</p>
<h3 id="全新的项目"><a href="#全新的项目" class="headerlink" title="全新的项目"></a>全新的项目</h3><p>可以直接<code>cd packages</code>去对应的包下创建文件夹<code>npm init -y</code>等等，或者直接使用脚手架<code>npx create-react-app main-app</code>创建新项目</p>
<h3 id="已有的项目"><a href="#已有的项目" class="headerlink" title="已有的项目"></a>已有的项目</h3><p>使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna import &lt;project url&gt;</span><br></pre></td></tr></table></figure>
<p><img src="%E5%AF%BC%E5%85%A5%E6%96%B0%E5%8C%85.png" alt=""><br><img src="%E5%AF%BC%E5%85%A5%E6%96%B0%E5%8C%85%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h2><p>建立相互依赖的包之间的软连接并安装其他的依赖, 默认是<code>npm i</code>,因为我们指定过<code>yarn</code>，因此执行<code>yarn install</code>,会把所有包的依赖安装到根<code>node_modules</code>.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna bootstrap</span><br></pre></td></tr></table></figure>

<h2 id="向项目中添加依赖"><a href="#向项目中添加依赖" class="headerlink" title="向项目中添加依赖"></a>向项目中添加依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna add &lt;dependencies&gt; --scope=&lt;project&gt;</span><br></pre></td></tr></table></figure>

<p><img src="%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<p><img src="%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96.png" alt=""></p>
<h2 id="组织Workspaces"><a href="#组织Workspaces" class="headerlink" title="组织Workspaces"></a>组织Workspaces</h2><p>通常起项目的时候，最好能在根目录配置对应的命令，这里可以参考<a href="https://zhuanlan.zhihu.com/p/381794854" target="_blank" rel="noopener"><code>yarn workspaces</code></a>的组织方法</p>
<p>根目录下<code>start</code>命令意味着执行<code>package.json</code>里<code>name</code>为<code>react-code-demo</code>的<code>start</code>命令</p>
<p>根目录<code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"root"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"workspaces"</span>: [</span><br><span class="line">    <span class="string">"packages/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"lerna"</span>: <span class="string">"^5.5.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"yarn workspace react-code-demo start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目<code>react-code-demo</code>的<code>package.json</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"react-code-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ... // 下面还有不展示了</span><br></pre></td></tr></table></figure>

<p><img src="%E7%BB%84%E7%BB%87workspace.png" alt=""></p>
<h2 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h2><p>修改包对应的代码，<em>无需重启，无需复制</em>，由于对应包<code>lerna</code>都是软链到根目录<code>node_modules</code>，修改包信息会直接同步到顶层<code>node_modules</code>，因此刷新即可生效</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><code>lerna</code>提供两个指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna changed</span><br></pre></td></tr></table></figure>

<p>列出下次发版<code>lerna publish</code>要更新的包。</p>
<p>原理： 需要先<code>git add</code>,<code>git commit</code> 提交。 然后内部会运行<code>git diff --name-only v版本号</code>，搜集改动的包，就是下次要发布的，并不是网上人说的所有包都是同一个版全发布</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna publish</span><br></pre></td></tr></table></figure>

<p>首先对应的<code>package.json</code>要配置<code>publishConfig</code>，属于<code>npm</code>相关内容不再赘述，执行命令</p>
<p>会打<code>tag</code>，上传<code>git</code>,上传<code>npm</code></p>
<hr>
<p>基本使用如下，开发者可以根据需求自定义命令，如清理<code>node_modules</code>、是否需要依据<code>package.lock.json</code>等安装，五花八门，等发现更有价值的持续更新。</p>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><blockquote>
<p>Lerna 中文详解教程：<a href="https://juejin.cn/post/6844903856153821198#heading-21" target="_blank" rel="noopener">https://juejin.cn/post/6844903856153821198#heading-21</a><br>lerna.js：monorepos项目管理模式简单实践: <a href="https://developer.aliyun.com/article/1007301" target="_blank" rel="noopener">https://developer.aliyun.com/article/1007301</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>包管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>TS高级类型</title>
    <url>/2022/07/28/TS%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>css八股文</title>
    <url>/2022/07/01/css%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>setState到底是同步还是异步的</title>
    <url>/2020/07/25/setState/</url>
    <content><![CDATA[<h4 id="setState同步还是异步"><a href="#setState同步还是异步" class="headerlink" title="setState同步还是异步"></a>setState同步还是异步</h4><ul>
<li>setState有时表现出异步,有时表现出同步,在<strong>合成事件</strong>和<strong>钩子函数</strong>中表现异步</li>
<li>setState批量更新优化是<strong>建立在合成事件和钩子函数</strong>之上的,在原生事件和setTimeout中不会发生异步.(顺序为setState =&gt; 钩子函数 =&gt; 合并更新状态)</li>
</ul>
<a id="more"></a>
<hr>
<h6 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h6><ul>
<li>React通过事件冒泡,将事件冒泡到document上面,再统一分发给中间层SyntheticEvent去执行事件</li>
</ul>
<h6 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h6><ul>
<li>钩子函数指生命周期的钩子</li>
</ul>
<hr>
<p><a href="https://www.jianshu.com/p/8d8f9aa4b033" target="_blank" rel="noopener">合成事件和钩子函数参考文档</a></p>
<h4 id="setState之后到底发生了什么"><a href="#setState之后到底发生了什么" class="headerlink" title="setState之后到底发生了什么"></a>setState之后到底发生了什么</h4><p>setState有两个注意事项:<br>官网提供:</p>
<ol>
<li>出于性能考虑，React 可能会把多个 setState() 调用<strong>合并成一个</strong>调用</li>
<li>因为 this.props 和 this.state 可能会异步更新，所以你<strong>不要依赖他们的值</strong>来更新下一个状态<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>上述连续两次在点击事件调用setState<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><img src="setState%E6%B5%81%E7%A8%8B.png" alt=""><h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><h6 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h6></li>
<li>首先调用实例的updater上的enqueueSetState</li>
<li>目的是让setState入列<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  将setState事务放进队列中</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h6></li>
<li>将更新状态的组件也放入队列中</li>
<li>将新的state放进数组里 </li>
<li>用enqueueUpdate来处理将要更新的实例对象</li>
</ul>
<h6 id="目前达到的效果"><a href="#目前达到的效果" class="headerlink" title="目前达到的效果"></a>目前达到的效果</h6><ul>
<li>setState在队列中</li>
<li>在这个setState执行过程里 我们将state放入了一个队列 将要更新的组件也放入了一个队列<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> enqueueSetState: <span class="function"><span class="keyword">function</span> (<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 获取当前组件的instance</span></span><br><span class="line"><span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将要更新的state放入一个数组里</span></span><br><span class="line"> <span class="keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">queue.push(partialState);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将要更新的component instance也放在一个队列里</span></span><br><span class="line">enqueueUpdate(internalInstance);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<!--more-->

</li>
</ul>
<h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><ul>
<li>调用enqueueUpdate执行更新操作,如果处在更新,那么只是将组件放入脏组件队列中<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果没有处于批量创建/更新组件的阶段，则处理update state事务</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果正处于批量创建/更新组件的过程，将当前的组件放在dirtyComponents数组中</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这个更新函数,接收一个组件的实例 首先判断是否处于更新阶段 如果不是 那么执行更新 如果处在更新阶段 那么我将组件的实例push到队列中 等待更新<h6 id="这个函数也说明了setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新"><a href="#这个函数也说明了setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新" class="headerlink" title="这个函数也说明了setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新"></a>这个函数也说明了setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新</h6></li>
</ul>
<h5 id="第三步拓展——批量更新策略-batchingStrategy"><a href="#第三步拓展——批量更新策略-batchingStrategy" class="headerlink" title="第三步拓展——批量更新策略(batchingStrategy)"></a>第三步拓展——批量更新策略(batchingStrategy)</h5><ul>
<li>第三步中,如果不处在更新状态,就执行<code>batchingStrategy.batchedUpdates(enqueueUpdate,component)</code></li>
</ul>
<h6 id="批量更新策略所在的对象"><a href="#批量更新策略所在的对象" class="headerlink" title="批量更新策略所在的对象"></a>批量更新策略所在的对象</h6><ul>
<li>batchedUpdates做了个判断,如果我处在更新状态,那么组件入列, 否则开启更新事务<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  <span class="comment">// 用于标记当前是否出于批量更新</span></span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 当调用这个方法时，正式开始批量更新</span></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前事务正在更新过程中，则调用enqueueUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则执行更新事务</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="第三步拓展——事务"><a href="#第三步拓展——事务" class="headerlink" title="第三步拓展——事务"></a>第三步拓展——事务</h5><ul>
<li><p>所谓事务,就是把函数做一层包装,开始是做一些操作,结束时做一些操作</p>
</li>
<li><p>下面是一个简单的事务例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'./Transaction'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己定义的 Transaction</span></span><br><span class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do sth.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [&#123;</span><br><span class="line">      initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'before method perform'</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'after method perform'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line">transaction.perform(testMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">// before method perform</span></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// after method perform</span></span><br></pre></td></tr></table></figure>
<p><img src="setState%E4%BA%8B%E5%8A%A1.png" alt=""></p>
</li>
<li><p>React源码的事务中有两个事务RESET_BATCHED_UPDATES(用于重置更新状态) FLUSH_BATCHED_UPDATES(再发起一个dom的批量更新,包括渲染和虚拟dom比对等等)</p>
</li>
<li><p>FLUSH_BATCHED_UPDATES这个事务的目的在于循环所有更新组件,执行update,调用组件更新的生命周期等等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>setState第一步:<strong>将state塞入数组,将组件交给更新队列</strong></li>
<li>setState第二步:更新队列进行更新,如果更新队列<strong>正在更新</strong>,将组件<strong>塞入脏组件队列</strong>.否则<strong>执行批量更新策略</strong></li>
<li>setState第三步:批量更新策略<strong>判断是否处在批量更新状态</strong>,如果<strong>正在更新</strong>,那么将<strong>更新组件塞入脏组件队列</strong>,否则把脏组件所有组件拿出来<strong>开启事务更新</strong></li>
<li>setState第四步,批量更新结束事务,在事务结束前,会调用FLUSH_BATCHED_UPDATES<strong>计算最新的<code>state</code>和<code>props</code></strong>.然后关闭事务</li>
<li>然后React可以拿到最新的state和props进行虚拟dom比对,虚拟dom比对完之后,会去渲染组件,此时如果有shouldUpdate,会进行一个是否渲染组件的判断</li>
</ul>
<h4 id="为什么setTimeout下setState是同步的"><a href="#为什么setTimeout下setState是同步的" class="headerlink" title="为什么setTimeout下setState是同步的"></a>为什么setTimeout下setState是同步的</h4><ul>
<li>关键在于批量更新策略什么时候开启的</li>
<li>React开启批量更新策略有两个位置,一个是钩子函数,一个是合成事件,可以将钩子函数和合成事件理解为一个大的事务,当触发时,React会开启批量更新策略.而当执行setTimeout的时候,大事务已经关闭,批量更新策略已经重置为false</li>
<li>实际上,调用setState触发了两个批量更新事务,相当于同步更新的过程了.</li>
</ul>
<h4 id="面试问答"><a href="#面试问答" class="headerlink" title="面试问答"></a>面试问答</h4><ul>
<li>问: setState过后到底发生了什么?</li>
<li>答: 将组件交给更新队列,将state塞入数组,然后执行队列更新方法,如果队列正在更新,组件就塞入脏组件,否则执行批量更新策略, 批量更新策略会去判断是否正在批量更新,如果正在更新,会把队列放入脏组件,否则循环脏组件队列开启事务执行批量更新,然后在事务结束前计算最新state和props,React拿到他们去进行虚拟dom比对,组件渲染,判断shouldUpdate,进行更新.更新完执行componentDidUpdate…</li>
</ul>
<p><a href="https://juejin.im/post/5aa25967518825558251f61f" target="_blank" rel="noopener">React - setState源码分析（小白可读）</a><br><a href="https://imweb.io/topic/5b189d04d4c96b9b1b4c4ed6" target="_blank" rel="noopener">揭密React setState</a><br><a href="https://juejin.im/post/5d7f219a51882501734c2921" target="_blank" rel="noopener">react源码分析之-setState是异步还是同步？</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP相关(持续更新)</title>
    <url>/2022/06/22/TCP%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li><p>客户端向服务端发送标记位为<code>SYN</code>，序列号<code>seq = x</code>，发起连接</p>
</li>
<li><p>服务端向客户端响应，发送<code>SYN</code>和<code>ACK</code>的标记位，<code>seq = y, ack = x + 1</code>的序列号</p>
</li>
<li><p>客户端向服务端响应，发送<code>ACK</code>为标记位，<code>ack = y + 1</code>的序列号</p>
</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li><p>客户端向服务端发起断开连接的请求，<code>FIN</code>作为标记位，<code>seq = p</code>作为序列号</p>
</li>
<li><p>服务端响应客户端，<code>ACK</code>作为标志位，<code>ack = p + 1</code></p>
</li>
<li><p>服务端向客户端发起可以关闭的请求，<code>FIN ACK</code>作为标记位，<code>seq = q，ack = p + 1</code></p>
</li>
<li><p>客户端响应服务端的关闭请求，<code>ACK</code>作为标记位，<code>ack = q + 1</code>，服务端关闭</p>
</li>
<li><p>客户端等待两个<code>MSL</code>后关闭</p>
</li>
</ol>
<h2 id="DoS-DDoS"><a href="#DoS-DDoS" class="headerlink" title="DoS/DDoS"></a>DoS/DDoS</h2><p>发送请求连接的握手之后，会进入半连接状态，进入半连接队列。</p>
<p>原理：<code>DDoS</code>就是伪造客户端，疯狂发请求导致服务器资源耗尽</p>
<p>解决方案：响应后不分配资源，设置<code>Cookie</code>，客户端第三次握手的时候带上这个<code>Cookie</code>给服务端做校验</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>本质就是双指针，两个队列，一个发送窗口，一个接收窗口</p>
<p>发送窗口有以下几个</p>
<ul>
<li>已发送已响应</li>
<li>已发送未响应</li>
<li>未发送已响应</li>
<li>未发送未响应</li>
</ul>
<p>接收窗口有以下几个</p>
<ul>
<li>已接收已响应</li>
<li>已接收未响应</li>
</ul>
<p>流量控制逻辑：</p>
<ol>
<li>假设两个队列默认窗口200</li>
<li>客户端发了200个字节，服务端处理了前100个之后，后面只能处理40个</li>
<li>服务端可用窗口缩小60个，还剩140，因为还有60没处理</li>
<li>服务端ack报文告诉客户端处理情况，客户端缩小为140，因为还有60个待发</li>
</ol>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p>拥塞窗口可以理解为发送窗口的限制，发送窗口的实际大小为<code>Min{拥塞窗口， 接收窗口}</code></p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>拥塞窗口大小随着收到的<code>ack</code>的增加而增加，每次<code>+1</code></p>
<h3 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h3><p>发了1-7个包，丢了第5个，那么会通过<code>left edge</code>和<code>right edge</code>告知发送端已经收到了哪些区间的数据报，第5个包没到就重传这个包，叫<strong>选择性重传</strong></p>
]]></content>
  </entry>
  <entry>
    <title>React-render阶段(一)</title>
    <url>/2021/06/01/React-render%E9%98%B6%E6%AE%B5%E4%B8%80/</url>
    <content><![CDATA[<h1 id="React-render阶段-一"><a href="#React-render阶段-一" class="headerlink" title="React-render阶段(一)"></a>React-render阶段(一)</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>React</code>在<code>16.8</code>版本之后, 使用<code>Fiber</code>提供了任务的优先级，中断可恢复的能力(开启<code>CM</code>模式). <code>React</code>通过<code>Scheduler</code>将高优先级的任务率先扔进<code>Reconciler</code>, <code>Reconcile</code>阶段创建了每个节点(其中可能经历<code>复用或者diff</code>等),生成<code>Fiber</code>树,并生成对应的<code>dom</code>树(暂未插入到页面),这个阶段我们称之为<code>render</code>阶段(渲染阶段)</p>
<p><code>React Fiber</code>使用了双缓存机制, 提供了两棵<code>Fiber</code>树, 当前展示的这棵树我们称之为<code>current</code>树(本次更新的上一次更新的树), 还有一棵是首次更新或者触发更新后在内存中生成的树, 我们称之为<code>WorkInProgress</code>树</p>
<h3 id="双缓存"><a href="#双缓存" class="headerlink" title="双缓存"></a>双缓存</h3><p><code>current</code>树: <code>current</code>树上的每一个工作单元展示了当前页面的<code>dom</code>情况, 首屏渲染时, <code>current</code>树只存在应用程序的根<code>rootFiber</code>节点</p>
<p><code>workInProgress</code>树: <code>workInProgress</code>树上的每一个工作单元的形成会在内存中执行, 渲染<code>mount</code>或者<code>update</code>时的更新逻辑</p>
<blockquote>
<p>具体可以参考卡老师写的React揭秘中理念篇的Fiber结构的工作原理,来详细的理解双缓存的概念——<a href="https://react.iamkasong.com/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">什么是双缓存</a>。</p>
</blockquote>
<a id="more"></a>

<h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><p><code>render</code>阶段开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>,取决于当前的模式. 这个函数是<code>React</code>整个流程,包括<code>render阶段</code>和<code>commit阶段</code></p>
<p><img src="%E6%BA%90%E7%A0%81%E8%B5%B7%E7%82%B9.png" alt=""></p>
<p>上图红框标出三个断点, 第一个断点是<code>render阶段</code>的核心</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootSync</span>(<span class="params">root, lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDevToolsPresent) &#123;</span><br><span class="line">        <span class="keyword">var</span> memoizedUpdaters = root.memoizedUpdaters;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memoizedUpdaters.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          restorePendingUpdaters(root, workInProgressRootRenderLanes);</span><br><span class="line">          memoizedUpdaters.clear();</span><br><span class="line">        &#125; <span class="comment">// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.</span></span><br><span class="line">        <span class="comment">// If we bailout on this work, we'll move them back (like above).</span></span><br><span class="line">        <span class="comment">// It's important to move them now in case the work spawns more work at the same priority with different updaters.</span></span><br><span class="line">        <span class="comment">// That way we can keep the current update and future updates separate.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        movePendingFibersToMemoized(root, lanes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置调度队列,并从root节点(新的高优先级的节点)开始调度</span></span><br><span class="line">    prepareFreshStack(root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    markRenderStarted(lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 尝试循环创建工作单元</span></span><br><span class="line">      workLoopSync();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleError(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// .....</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressRootExitStatus;</span><br><span class="line">&#125; <span class="comment">// Th</span></span><br></pre></td></tr></table></figure>
<p>这个方法最重要的两个方法, 一个是<code>prepareFreshStack</code>, 这个方法是用于重置调度队列,并从<code>root</code>节点(新的高优先级的节点)开始调度, 这个函数内部调用了<code>createWorkInProgress</code>, 我们放到下面一会讲</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="comment">//和上面的区别在于shouldYield, 这个代表是否存在剩余时间</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个是<code>workLoopSync</code>, 循环创建调用<code>performUnitOfWork</code>, 通过函数名可以看到是循环执行工作单元, 为遍历到的每个<code>Fiber</code>节点提供<code>beginWork</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = unitOfWork.alternate;</span><br><span class="line">  setCurrentFiber(unitOfWork);</span><br><span class="line">  <span class="keyword">var</span> next;</span><br><span class="line">  <span class="keyword">if</span> ( (unitOfWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">    startProfilerTimer(unitOfWork);</span><br><span class="line">    <span class="comment">// 开始beginWork阶段, 主要是创建当前节点的子Fiber节点</span></span><br><span class="line">    next = beginWork$<span class="number">1</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next = beginWork$<span class="number">1</span>(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetCurrentFiber();</span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果子节点为null, 那么直接把当前节点completeWork</span></span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactCurrentOwner$<span class="number">2.</span>current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>beginWork</code>的主要作用在于创建当前节点的子<code>Fiber</code>节点, 该方法为<code>render</code>阶段递归阶段<em>递</em>阶段的主要方法</p>
<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> updateLanes = workInProgress.lanes;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (workInProgress._debugNeedsRemount &amp;&amp; current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This will restart the begin phase with a new fiber.</span></span><br><span class="line">      <span class="keyword">return</span> remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || <span class="literal">null</span>, workInProgress.mode, workInProgress.lanes));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前的workInProgress树上正在工作的单元对应的alternate对应的Fiber节点</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">var</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || hasContextChanged() || (</span><br><span class="line">     workInProgress.type !== current.type )) &#123;</span><br><span class="line">       <span class="comment">// props或者context变化, 有更新的逻辑</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;<span class="comment">// 当前fiber上是否存在更新，如果存在那么更新的优先级是否和本次整棵fiber树调度的优先级一致</span></span><br><span class="line">      <span class="comment">// 以下表示当前fiber上的更新与本颗fiber树上的更新不一致或者说当前fiber上不存在更新</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里主要是针对不接受更新的ReactElement对象, 进行复用, 针对不同的类型传递一些属性</span></span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123; </span><br><span class="line">        <span class="keyword">case</span> HostRoot:</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        <span class="comment">// 这个解决了context改变的时候suspense没有触发更新的问题</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="comment">// 根据tag判断当前工作单元的类型, 基于当前类型进入不同的逻辑</span></span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> _Component = workInProgress.type;</span><br><span class="line">        <span class="keyword">var</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">        <span class="keyword">var</span> resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);</span><br><span class="line">        <span class="keyword">return</span> updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> _Component2 = workInProgress.type;</span><br><span class="line">        <span class="keyword">var</span> _unresolvedProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> xxxx:</span><br><span class="line">      <span class="comment">// ..........</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>beginWork</code>主要做了几件事情</p>
<ol>
<li>根据<code>current</code>判断这个工作单元处于挂载还是更新, 根据<code>新旧props</code>和<code>context</code>判断能否复用</li>
<li>如果不能复用则更新, 根据当前工作单元的类型决定进入什么逻辑<ul>
<li>工作单元类型可以在<code>src/react-reconciler/ReactWorkTags.js</code>中找到, <code>div</code>属于<code>HostComponent</code></li>
</ul>
</li>
</ol>
<h3 id="beginWork中的更新逻辑-以div举例"><a href="#beginWork中的更新逻辑-以div举例" class="headerlink" title="beginWork中的更新逻辑(以div举例)"></a>beginWork中的更新逻辑(以div举例)</h3><p>如果当前工作单元是<code>div</code>, 那么会进入<code>updateHostComponent</code>的更新逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    tryToClaimNextHydratableInstance(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">var</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">var</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="keyword">var</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line">  <span class="comment">// 文本节点的优化, 当div下只有一个单独的文本节点,那么react不会单独为这个Fiber节点创建子节点</span></span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    workInProgress.flags |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line">  <span class="comment">// reconcileChildren是diff子节点, 如果current是null, 说明是mount, 否则是update</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对<code>div</code>的更新, 主要调用了<code>reconcileChilren</code>的方法, 以下是<code>reconcileChilren</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// mount时</span></span><br><span class="line">    workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// update时</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>reconcileChilren</code>在<code>mount</code>时调用了<code>mountChildFibers</code>, 在<code>update</code>时调用了<code>reconcileChildFibers</code>, 这两个方法都是调用的<code>ChildReconciler</code>, 返回一个节点并赋值给<code>workInProgress.child</code>, 因此可以验证<code>beginWork</code>的目的是创建当前节点的子<code>Fiber</code> 节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>ChildReconciler</code>的参数的含义代表的是是否需要追踪副作用, <code>mount</code>时不需要追踪副作用,原因是我们只需要被插入一次, 如果追踪副作用, 那么每个节点都将被打上<code>effectTag</code>为<code>Placement</code>(插入), 这样commit阶段所有节点都会被插入一次, 这种频繁操作<code>dom</code>的行为显然是消耗性能且没有必要的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ......其他节点的diff算法</span></span><br><span class="line">  <span class="comment">// 这里只展示单一节点的diff算法的源码</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params">returnFiber, currentFirstChild, element, lanes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = element.key;</span><br><span class="line">    <span class="keyword">var</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> If key === null and child.key === null, then this only applies to</span></span><br><span class="line">      <span class="comment">// the first item in the list.</span></span><br><span class="line">      <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">        <span class="keyword">var</span> elementType = element.type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">            <span class="keyword">var</span> existing = useFiber(child, element.props.children);</span><br><span class="line">            existing.return = returnFiber;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">              existing._debugSource = element._source;</span><br><span class="line">              existing._debugOwner = element._owner;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (child.elementType === elementType || ( <span class="comment">// Keep this check inline so it only runs on the false path:</span></span><br><span class="line">           isCompatibleFamilyForHotReloading(child, element) ) || <span class="comment">// Lazy types should reconcile their resolved type.</span></span><br><span class="line">          <span class="comment">// We need to do this after the Hot Reloading check above,</span></span><br><span class="line">          <span class="comment">// because hot reloading has different semantics than prod because</span></span><br><span class="line">          <span class="comment">// it doesn't resuspend. So we can't let the call below suspend.</span></span><br><span class="line">           <span class="keyword">typeof</span> elementType === <span class="string">'object'</span> &amp;&amp; elementType !== <span class="literal">null</span> &amp;&amp; elementType.$$<span class="keyword">typeof</span> === REACT_LAZY_TYPE &amp;&amp; resolveLazy(elementType) === child.type) &#123;</span><br><span class="line">            deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> _existing = useFiber(child, element.props);</span><br><span class="line"></span><br><span class="line">            _existing.ref = coerceRef(returnFiber, child, element);</span><br><span class="line">            _existing.return = returnFiber;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">              _existing._debugSource = element._source;</span><br><span class="line">              _existing._debugOwner = element._owner;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> _existing;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="comment">// Didn't match.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        deleteRemainingChildren(returnFiber, child);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deleteChild(returnFiber, child);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      child = child.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">var</span> created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);</span><br><span class="line">      created.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> created;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> _created4 = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line"></span><br><span class="line">      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">      _created4.return = returnFiber;</span><br><span class="line">      <span class="keyword">return</span> _created4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, lanes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isUnkeyedTopLevelFragment = <span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span> &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125; <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">'object'</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REACT_LAZY_TYPE:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">var</span> payload = newChild._payload;</span><br><span class="line">            <span class="keyword">var</span> init = newChild._init; <span class="comment">// <span class="doctag">TODO:</span> This function is supposed to be non-recursive.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return deleteRemainingChildren(returnFiber, currentFirstChild);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动执行<code>ChildReconciler</code>会返回<code>reconcileChildFibers</code>, 这里巧妙的使用了闭包, 根据<code>newChild</code>中的<code>$$typeof</code>去进行不同逻辑.<br>参数的<code>newChild</code>可以看到向上追溯看到是当前<code>workInProgress.pendingProps.children</code>, 也就是当前工作单元<code>props</code>上的<code>children</code><br><code>reconcileSingleElement</code>代码已经展示在上面, 是单一节点的<code>diff</code>算法, 等讲到<code>diff</code>算法时在详细解读</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeSingleChild</span>(<span class="params">newFiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This is simpler for the single child case. We only need to do a</span></span><br><span class="line">  <span class="comment">// placement for inserting new children.</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">    newFiber.flags |= Placement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>placeSingleChild</code>就是为新节点添加<code>Placement</code>操作(<code>mount</code>时不添加), 并将其返回并添加到<code>workInProgress.child</code>上</p>
<p><em>以上为<code>beginWork</code>的完整流程, 目的在于创建当前工作单元的第一个子<code>Fiber</code>节点</em></p>
<hr>
<p>接下来补充一点逻辑, 为了方便调试, 并解决一些个人遇到的疑难困惑点</p>
<h4 id="bailoutOnAlreadyFinishedWork"><a href="#bailoutOnAlreadyFinishedWork" class="headerlink" title="bailoutOnAlreadyFinishedWork"></a>bailoutOnAlreadyFinishedWork</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bailoutOnAlreadyFinishedWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress.dependencies = current.dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    stopProfilerTimerIfRunning();</span><br><span class="line">  &#125;</span><br><span class="line">  markSkippedUpdateLanes(workInProgress.lanes); <span class="comment">// Check if the children have any pending work.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  cloneChildFibers(current, workInProgress);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用在于复用<code>Fiber</code>节点, 函数调用的时机仅仅会发生在<code>update</code>时, 根据双缓存机制, 当更新时, <code>current</code>树已经存在对应的<code>Fiber</code>节点, 在上文<code>beginWork</code>中有以下这么一段代码, 我们可以看到当<code>current</code>树不为<code>null</code>并且<em>新旧Props</em> <em><code>context</code>和<code>type</code>无变化</em>的时候, 会复用节点(即<code>return bailoutOnAlreadyFinishedWork</code>),<code>bailoutOnAlreadyFinishedWork</code>调用<code>cloneChildFibers</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前的workInProgress树上正在工作的单元对应的alternate对应的Fiber节点</span></span><br><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> oldProps = current.memoizedProps;</span><br><span class="line">  <span class="keyword">var</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldProps !== newProps || hasContextChanged() || (</span><br><span class="line">   workInProgress.type !== current.type )) &#123;</span><br><span class="line">     <span class="comment">// props或者context变化, 有更新的逻辑</span></span><br><span class="line">    didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主要是针对不接受更新的ReactElement对象, 进行复用, 针对不同的类型传递一些属性</span></span><br><span class="line">    <span class="keyword">switch</span> (workInProgress.tag) &#123; </span><br><span class="line">      <span class="keyword">case</span> HostRoot:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">      <span class="comment">// 这个解决了context改变的时候suspense没有触发更新的问题</span></span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cloneChildFibers"><a href="#cloneChildFibers" class="headerlink" title="cloneChildFibers"></a>cloneChildFibers</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneChildFibers</span>(<span class="params">current, workInProgress</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(current === <span class="literal">null</span> || workInProgress.child === current.child)) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"Resuming work not yet implemented."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress.child === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentChild = workInProgress.child;</span><br><span class="line">  <span class="keyword">var</span> newChild = createWorkInProgress(currentChild, currentChild.pendingProps);</span><br><span class="line">  workInProgress.child = newChild;</span><br><span class="line">  newChild.return = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentChild.sibling !== <span class="literal">null</span>) &#123;</span><br><span class="line">    currentChild = currentChild.sibling;</span><br><span class="line">    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);</span><br><span class="line">    newChild.return = workInProgress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newChild.sibling = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从名称可以读出, 这个函数的作用就是<code>clone</code>当前工作单元的子<code>Fiber</code>节点, 那么复用节点目的就是把<code>current</code>树上对应的现在<code>Fiber</code>节点的子<code>Fiber</code>节点保存到当前工作单元的<code>child</code>属性下, 这个方法会调用<code>createWorkInProgress</code>, 所以调用<code>createWorkInProgress</code>目的创建的不是当前工作单元, 而是当前工作单元的子工作单元</p>
<h4 id="createWorkInProgress"><a href="#createWorkInProgress" class="headerlink" title="createWorkInProgress"></a>createWorkInProgress</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span>(<span class="params">current, pendingProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> workInProgress = current.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果workInProgress是null, 那么为其创建一个Fiber节点</span></span><br><span class="line">    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);</span><br><span class="line">    workInProgress.elementType = current.elementType;</span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略部分赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接两课Fiber树</span></span><br><span class="line">    workInProgress.alternate = current;</span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.pendingProps = pendingProps; <span class="comment">// Needed because Blocks store data on type.</span></span><br><span class="line"></span><br><span class="line">    workInProgress.type = current.type; <span class="comment">// We already have an alternate.</span></span><br><span class="line">    <span class="comment">// Reset the effect tag.</span></span><br><span class="line"></span><br><span class="line">    workInProgress.flags = NoFlags; <span class="comment">// The effects are no longer valid.</span></span><br><span class="line"></span><br><span class="line">    workInProgress.subtreeFlags = NoFlags;</span><br><span class="line">    workInProgress.deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  workInProgress.flags = current.flags &amp; StaticMask;</span><br><span class="line">  workInProgress.childLanes = current.childLanes;</span><br><span class="line">  workInProgress.lanes = current.lanes;</span><br><span class="line">  workInProgress.child = current.child;</span><br><span class="line">  workInProgress.memoizedProps = current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState = current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue = current.updateQueue; <span class="comment">// Clone the dependencies object. This is mutated during the render phase, so</span></span><br><span class="line">  <span class="comment">// it cannot be shared with the current fiber.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentDependencies = current.dependencies;</span><br><span class="line">  workInProgress.dependencies = currentDependencies === <span class="literal">null</span> ? <span class="literal">null</span> : &#123;</span><br><span class="line">    lanes: currentDependencies.lanes,</span><br><span class="line">    firstContext: currentDependencies.firstContext</span><br><span class="line">  &#125;; <span class="comment">// These will be overridden during the parent's reconciliation</span></span><br><span class="line"></span><br><span class="line">  workInProgress.sibling = current.sibling;</span><br><span class="line">  workInProgress.index = current.index;</span><br><span class="line">  workInProgress.ref = current.ref;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createWorkInProgress</code>从名称可以看出作用在于创建<code>workInProgress</code>节点, 这个函数的调用时机在<code>cloneChildFibers</code>或者<code>prepareFreshStack</code>中. 这个函数首先判断<code>current.alternate</code>是否为空, 这里解释一下, <code>current.alternate</code>为空说明当前工作单元的子工作单元是更新后新创建的, 这个时候我们会为新的工作单元创建一个<code>Fiber</code>节点, 否则我们对子工作单元进行一个赋值操作即可</p>
<h2 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h2><p>这里梳理一下上述所说的全流程</p>
<p><img src="React-render%E9%98%B6%E6%AE%B5_%E9%80%92%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png" alt=""></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码分析diff算法</title>
    <url>/2022/06/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="从源码分析diff算法"><a href="#从源码分析diff算法" class="headerlink" title="从源码分析diff算法"></a>从源码分析diff算法</h1><blockquote>
<p>以下需要建立在对<code>react理念</code>和<code>react render阶段</code>有一定理解的基础上</p>
</blockquote>
<p><code>diff</code>算法发生在<code>beginWork</code>函数中</p>
<p>满足<code>current !== null</code>时进行<code>diff</code>(为<code>null</code>时意味着本次是<code>mount</code>阶段)，<strong>mount阶段beginWork生成的子Fiber均被打上Placement的标记并存储在flags属性上(前几个版本存在effectTag上)</strong></p>
<p><code>diff</code>算法本质是<strong>将current树上的fiber与组件update后返回的jsx进行对比，生成打好flags的子Fiber节点</strong></p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>以<code>div</code>举例，<code>beginWork</code>会根据 <strong>当前workInProgress的tag(即上一次beginWork生成好的子Fiber节点)</strong> 来判断更新的类型, <code>div</code>属于<code>HostComponent</code>将执行<code>updateHostComponent</code></p>
<p><img src="diff%E7%AE%97%E6%B3%95%E5%85%A5%E5%8F%A3.png" alt=""></p>
<h2 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h2><p>以以下代码为例，<code>workInProgress</code>为下图红框时</p>
<p><img src="diff%E5%8D%95%E8%8A%82%E7%82%B9%E6%A1%88%E4%BE%8B.png" alt=""></p>
<p>由下图可以看出，调用<code>reconcileChildren</code>传入的<code>nextChildren</code>是当前<code>workInProgress</code>的 <code>children</code>, 以我们的例子来说就是<code>div</code>下的<code>jsx</code></p>
<p>注意点：<code>div</code>下的<code>jsx</code>并非单一节点时，<code>nextChildren</code>为数组类型，因此diff算法可能是<strong>链表与数组</strong>间的比较</p>
<p><img src="diff%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A1.png" alt=""></p>
<p>下图可知，比较对象是<code>current.child</code>与上面说的<code>nextChildren</code>的比较</p>
<p><img src="%E6%AF%94%E8%BE%83%E5%AF%B9%E8%B1%A12.png" alt=""></p>
<h2 id="diff流程"><a href="#diff流程" class="headerlink" title="diff流程"></a>diff流程</h2><p>由下图可知，<code>diff</code>主要分为<strong>jsx返回的是单节点的diff</strong>和<strong>jsx返回的是多节点的diff</strong></p>
<p>单节点中，至于其他的关于<code>Portal、TextNode</code>都比较好理解，简单概述一下</p>
<ol>
<li><p><code>Portal</code>的更新和单节点的diff<code>算法</code>很像</p>
</li>
<li><p>如果是文本节点，则将<code>current.child</code>的比较节点全部删除(原因是因为<code>beginWork</code>一次只生成一个<code>child</code>节点), 并基于此<code>current.child</code>重新克隆一个<code>fiber</code>节点</p>
</li>
</ol>
<p><img src="diff%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h3 id="jsx返回的是单节点的diff"><a href="#jsx返回的是单节点的diff" class="headerlink" title="jsx返回的是单节点的diff"></a>jsx返回的是单节点的diff</h3><p>下图红框表示<strong>节点是更新的节点</strong>, 棕色框表示<strong>节点是新增的节点</strong></p>
<ol>
<li><p>红框意味着刚进来有值，说明当前<code>current.child</code>处在同层级</p>
</li>
<li><p>棕框意味着当前界面上的节点不存在，本次更新或者挂载的是一个全新的节点，因此要为当前全新的节点创建一个<code>fiber</code>并返回</p>
</li>
</ol>
<p><img src="%E5%8D%95%E8%8A%82%E7%82%B9%E7%9A%84diff_1.png" alt=""></p>
<p>主要关注红框的部分, 核心逻辑如下</p>
<ol>
<li><p><code>key</code>不相同，把<strong>当前</strong><code>current.child(即当前current树上进行diff的节点)</code>删除，将指针移到<code>current.child</code>的兄弟节点进行比较</p>
<ul>
<li>注意点：<code>key</code>不相同不会把所有兄弟节点都删除，只会删除当前比较的，如果兄弟节点<code>key</code>相同还是会有复用的可能性</li>
</ul>
</li>
<li><p><code>key</code>相同，比较<code>elementType</code>是否相同，如果相同，直接基于当前<code>current.child</code>创建一个<code>fiber</code></p>
<ul>
<li>注意如果复用这个<code>fiber</code>节点的<code>child</code>是和当前的<code>current.child</code>完全一样，可以减少渲染</li>
</ul>
</li>
<li><p><code>key</code>相同，如果<code>type</code>不相同，要把<code>current.child</code>及其的兄弟节点一并删除</p>
</li>
</ol>
<p>看如下代码，<code>React</code>不会复用更新前的<code>div</code>，而是把两个全都删了，重新创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新前</span></span><br><span class="line">&lt;p key=<span class="string">"1"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;div key="1"&gt;1&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新后</span></span><br><span class="line">&lt;div key=<span class="string">"1"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="%E5%8D%95%E8%8A%82%E7%82%B9diff_2.png" alt=""></p>
<h3 id="jsx返回的是多节点的diff-Array-Iterator"><a href="#jsx返回的是多节点的diff-Array-Iterator" class="headerlink" title="jsx返回的是多节点的diff(Array, Iterator)"></a>jsx返回的是多节点的diff(Array, Iterator)</h3><h4 id="第一轮遍历"><a href="#第一轮遍历" class="headerlink" title="第一轮遍历"></a>第一轮遍历</h4><h5 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h5><ol>
<li><p><code>oldFiber</code>遍历完或者<code>newChildren</code>遍历完或者说<code>当前diff的两个节点key不相同</code></p>
</li>
<li><p>如果<code>key</code>相同，继续判断，调用<code>updateElement</code>，方法比较简单</p>
<ul>
<li>如果<code>type</code>不相同那么不能复用，这个时候会基于当前的<code>newFiber</code>创建<code>fiber</code>, 并将当前的<code>oldFiber</code>删除，<strong>继续遍历</strong></li>
<li>如果<code>type</code>相同，那么可以复用</li>
</ul>
</li>
</ol>
<p><img src="%E5%A4%9A%E8%8A%82%E7%82%B9diff%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86.png" alt=""></p>
<h4 id="第二轮遍历"><a href="#第二轮遍历" class="headerlink" title="第二轮遍历"></a>第二轮遍历</h4><p>第二轮遍历是会带着第一轮遍历的结果去进行遍历，结果有以下情况：</p>
<p>下图先解释比较容易得两种情况：</p>
<ol>
<li><p><code>newIdx === newChildren.length</code>意味着新节点遍历完，那么直接把剩余没遍历的<code>oldFiber</code>删掉即可</p>
</li>
<li><p><code>oldFiber === null</code>意味着旧的节点遍历完了，那么遍历剩余的新节点依次创建<code>Fiber</code>即可</p>
</li>
</ol>
<p><img src="%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86_1.png" alt=""></p>
<p>下图解释最复杂的情况，能进下图的位置说明<code>newChildren</code>和<code>oldFiber</code>都没遍历完</p>
<ol>
<li><p><code>mapRemainingChildren</code>这个方法是为了在<code>O(1)</code>复杂度快速找到对应的<code>current节点</code>，因此把<code>key</code>或者<code>索引index</code>作为<code>key</code>，<code>current节点</code>作为<code>value</code>存在<code>map</code>中</p>
</li>
<li><p>遍历剩下的<code>newFiber</code>，先找<code>key</code>一样的，没有<code>key</code>就找同位置的，<strong>为了找到移动的节点</strong>，调用<code>updateElement——能复用就复用，不能复用就自己创建</code></p>
</li>
</ol>
<p><img src="%E7%AC%AC%E4%BA%8C%E8%BD%AE%E9%81%8D%E5%8E%86_2.png" alt=""></p>
<h4 id="lastPlacedIndex详细解释-精髓"><a href="#lastPlacedIndex详细解释-精髓" class="headerlink" title="lastPlacedIndex详细解释(精髓)"></a>lastPlacedIndex详细解释(精髓)</h4><p><code>lastPlacedIndex</code>这个索引解释——<strong>新创建的Fiber节点在dom中要插入的位置</strong></p>
<ol>
<li><p>如果当前节点没有被复用，是<code>全新创建</code>的话，那么这个值不变，并打上<code>Placement</code></p>
</li>
<li><p>如果当前节点被复用了，这个值是返回<code>Max{oldIndex, lastPlacedIndex}</code></p>
</li>
<li><p>如果这个节点被复用了，<code>oldIndex &lt; lastPlacedIndex</code>需要移动</p>
</li>
</ol>
<p><img src="lastPlacedIndex.png" alt=""></p>
<h4 id="多节点diff总结"><a href="#多节点diff总结" class="headerlink" title="多节点diff总结"></a>多节点diff总结</h4><ol>
<li><p>第一次遍历用新旧同层判断key是否相同，不相同跳出，遍历完跳出</p>
</li>
<li><p>第二次遍历</p>
<p> 2.1 <code>oldFiber</code>遍历完，创建新节点。<code>newChildren</code>遍历完删除多的<code>oldFiber</code></p>
<p> 2.2 两个都没遍历完，将剩余的<code>oldFiber</code>存成map。遍历<code>newChildren</code>，如果可以找到可以复用，判断<code>oldIndex &lt; lastPlacedIndex</code>，标记<code>Placement</code>。并将<code>lastPlacedIndex</code>设置为<code>oldFiber</code>里<strong>当前遍历到的！！！最后一个可复用的节点</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>源码系列</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基本配置</title>
    <url>/2020/11/29/webpack/</url>
    <content><![CDATA[<h2 id="基本搭建"><a href="#基本搭建" class="headerlink" title="基本搭建"></a>基本搭建</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p>一顿yes直接搭建好基本的node环境<br><img src="%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure>
<p>安装webpack, webpack-cli, 由于是开发环境需要,加上–save-dev</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./index.js"</span>,</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建<code>index.js</code>, 新建<code>webpack.config.js</code>, <code>webpack</code>默认读取<code>webpack.config.js</code>导出的对象.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<p><code>webpack</code>默认读取根路径下的<code>webpack.config.js</code>文件, <code>npm</code>5.2之后提供了自动安装<code>npx</code> ,会自动查找当前依赖包中的可执行文件并执行<br><img src="%E6%88%90%E5%8A%9F%E6%89%A7%E8%A1%8C.jpg" alt=""></p>
<a id="more"></a>

<hr>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>定义了打包的基础目录, 一旦设置, 那么接下来配置设置的根路径将会是配置的基础目录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'app'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>文件打包的起点</p>
<ul>
<li>可以传入数组, 传入数组从前往后依次进行打包, 包名为main</li>
<li>可以传入对象, 每个键作为打包的包名， 值为打包的资源路径或者打包的描述符<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  entry: <span class="string">'./index.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以自定义包名</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./app.js'</span>,</span><br><span class="line">    home: &#123; <span class="attr">import</span>: <span class="string">'./contact.js'</span>, <span class="attr">filename</span>: <span class="string">'pages/[name][ext]'</span> &#125;,</span><br><span class="line">    about: &#123; <span class="attr">import</span>: <span class="string">'./about.js'</span>, <span class="attr">filename</span>: <span class="string">'pages/[name][ext]'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
多入口可以设置打包依赖， 减少包体积， 避免重复使用相同的包<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#123; <span class="attr">import</span>: [<span class="string">'./app.js'</span>, <span class="string">'./app2.js'</span>], <span class="attr">dependOn</span>: <span class="string">'react-vendors'</span> &#125;,</span><br><span class="line">    <span class="string">'react-vendors'</span>: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'prop-types'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
可以动态引入， 将在make事件中触发<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  entry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'./demo'</span> <span class="comment">// () =&gt; new Promise((resolve) =&gt; resolve(['./demo', './demo2']))</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>打包模式分为<code>development</code>和<code>production</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  mode: <span class="string">'development'</span> <span class="comment">// 'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以在打包时决定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack --mode&#x3D;development</span><br></pre></td></tr></table></figure>

<p>如果我们需要在不同模式下进行定义不同的打包行为， 我们可以定义为函数， 使用方法如下。</p>
<p><strong>开发环境打包文件<code>webpack.base.js</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="comment">// 这里注入基本配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>主打包文件<code>webpack.dev.js</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>)(&#123;</span><br><span class="line">    <span class="comment">// 这里将开发环境打包需要的配置注入</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过配置进行打包， 选择对应的打包文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack --config webpack.dev.js</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>打包的输出形态， 包括bundle和静态文件</p>
<h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p><code>filename</code> 是一个很常见的配置，就是对应于 <code>entry</code> 里面的输入文件。</p>
<p>这里可以使用可替换模板字符串的形式定义输出的打包文件名，浏览器存在缓存机制，如果名称相同，浏览器默认文件没有改变，这样打包文件名相同会使得获取文件出现问题，因此我们通过可替换模板字符串的形式定义输出的打包文件名。</p>
<ul>
<li>编译层<ul>
<li>name： chunk文件名</li>
</ul>
</li>
<li>chunk层<ul>
<li>id: 内部chunk的id</li>
<li>chunkhash：这个chunk的hash值</li>
</ul>
</li>
<li>模块层<ul>
<li>contenthash： 根据内容生成的hash</li>
<li>id：模块id</li>
<li>hash：模块的hash值</li>
</ul>
</li>
<li>文件层：<ul>
<li>file： 文件名称和路径</li>
<li>query： 带前缀 ? 的 query</li>
</ul>
</li>
<li>url层：<ul>
<li>url</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体参照<a href="https://webpack.docschina.org/configuration/output/#outputfilename" target="_blank" rel="noopener">模板字符串替换</a></p>
</blockquote>
<h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><p><code>chunkFilename</code> 指未被列在 <code>entry</code> 中，却又需要被打包出来的 <code>chunk</code> 文件的名称。一般来说，这个 <code>chunk</code> 文件指的就是要懒加载的代码。</p>
<p>注意点： 默认文件输出为<code>[id].js</code>或者遵循<code>output.filename</code>的设置，如果<code>output.filename</code>设置了<code>name</code>， 则会被预先替换为<code>id</code></p>
<blockquote>
<p>可以参照这篇文章看到<a href="https://www.cnblogs.com/skychx/p/webpack-filename-chunkFilename.html" target="_blank" rel="noopener">filename和chunkFilename的区别</a></p>
</blockquote>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>打包文件路径</p>
<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>外部资源路径，通常以<code>/</code>结尾, 默认参照路径为HTML页面所在的路径为准</p>
<p>例如如下配置，请求一个<code>chunk</code>就相当于请求<code>/assets/1.chunk.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/assets/'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'[id].chunk.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><p>组织打包的模块，库开发使用</p>
<h3 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h3><p>库打包引入的方式</p>
<hr>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p><code>module</code>对象用于模块的处理方式</p>
<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><h4 id="对应值为-Rule-数组"><a href="#对应值为-Rule-数组" class="headerlink" title="对应值为[Rule]数组"></a>对应值为<code>[Rule]</code>数组</h4><p><code>rules</code>作用在于提供模块的创建规则，提供对应的<code>loader</code>和解析器(<code>parser</code>)</p>
<h4 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h4><p><code>Rule</code>是一个对象，这个对象分为三部分</p>
<ul>
<li>条件匹配： 条件匹配通过 <code>test</code> 、 <code>include</code> 、 <code>exclude</code> 和 <code>resource</code> 对资源进行匹配(这个资源指的是请求的资源)，并且属性 <code>issuer</code> 对 <code>issuer</code> 匹配, 这个 <code>issuer</code> 指的是请求者的文件绝对路径。是导入时的位置。</li>
<li>应用规则： 对选中的文件使用 <code>use</code> 来应用 <code>loader</code>，按照从后往前的顺序应用， 并可以为loader传递参数。</li>
<li>嵌套规则：父规则(文档这里没怎么理解, 在我看来是指一般的规则)、 <code>rule</code>、<code>oneOf</code>的顺序，可以通过<code>enforce</code>强制修改顺序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ <span class="comment">// 以下对象对应一个Rule</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\\.css$/</span>, <span class="comment">// loader1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          test: <span class="regexp">/\\.js$/</span>, <span class="comment">// loader2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意： <code>loader</code> 顺序从右往左，从下往上执行，按照 <code>pitching</code> 顺序执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|- a-loader <span class="string">`pitch`</span></span><br><span class="line">  |- b-loader <span class="string">`pitch`</span></span><br><span class="line">    |- c-loader <span class="string">`pitch`</span></span><br><span class="line">      |- requested <span class="built_in">module</span> is picked up <span class="keyword">as</span> a dependency</span><br><span class="line">    |- c-loader normal execution</span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Rule-oneOf"><a href="#Rule-oneOf" class="headerlink" title="Rule.oneOf"></a>Rule.oneOf</h4><p>一旦匹配，就使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ <span class="comment">// 以下对象对应一个Rule</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\\.css$/</span>,</span><br><span class="line">        oneOf: [</span><br><span class="line">            &#123;</span><br><span class="line">                resourceQuery: <span class="regexp">/inline/</span>, <span class="comment">// foo.css?inline</span></span><br><span class="line">                use: <span class="string">'url-loader'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                resourceQuery: <span class="regexp">/external/</span>, <span class="comment">// foo.css?external</span></span><br><span class="line">                use: <span class="string">'file-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Rule-use"><a href="#Rule-use" class="headerlink" title="Rule.use"></a>Rule.use</h4><p>提供一个 <code>loader</code> 数组, 从右往左进行匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'less-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              noIeCompat: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Rule-exclude-include"><a href="#Rule-exclude-include" class="headerlink" title="Rule.exclude/include"></a>Rule.exclude/include</h4><p>排除/包括 <code>loader</code> 加载某个模块</p>
<h4 id="Rule-parse"><a href="#Rule-parse" class="headerlink" title="Rule.parse"></a>Rule.parse</h4><p>文件被 <code>loader</code> 执行后会转成一段js字符串， <code>parse</code>会将其转换为 <code>AST</code> 语法树，有了语法树就可以对代码为所欲为了，其中最重要的功能就是分析出这段代码依赖了哪些模块</p>
<h4 id="Rule-sideEffect"><a href="#Rule-sideEffect" class="headerlink" title="Rule.sideEffect"></a>Rule.sideEffect</h4><p>模块是否包含副作用</p>
<h4 id="Rule-type"><a href="#Rule-type" class="headerlink" title="Rule.type"></a>Rule.type</h4><p>设置匹配模块的类型，防止 <code>webpack</code> 自定义的行为发生，常用于自定义loader加载模块</p>
<h4 id="Rule-resolve"><a href="#Rule-resolve" class="headerlink" title="Rule.resolve"></a>Rule.resolve</h4><p>模块解析可以在模块层被配置, <code>Rule</code>层面的 <code>resolve</code> 会覆盖顶层的 <code>resolve配置</code></p>
<h3 id="UseEntry"><a href="#UseEntry" class="headerlink" title="UseEntry"></a>UseEntry</h3><p><code>Rule</code> 传入的形式，通常可以是对象或者一个函数, 一个必选的字符串形式的 <code>loader</code> 和一个可选的 <code>option</code></p>
<p>函数形式则会接受一个加载模块的对象参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          modules: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数形式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          outputPath: <span class="string">'svgs'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      (info) =&gt; (&#123;</span><br><span class="line">        loader: <span class="string">'svgo-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          plugins: [&#123;</span><br><span class="line">            cleanupIDs: &#123; <span class="attr">prefix</span>: basename(info.resource) &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h3><p>不解析所传递的正则表达式匹配到的文件，这里特别注意不匹配的文件不能存在<code>require</code>和<code>import</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="unsafeCache"><a href="#unsafeCache" class="headerlink" title="unsafeCache"></a>unsafeCache</h3><p>缓存模块是否需要解析， 首先得保证缓存开启。缓存未开启，默认为<code>false</code>。缓存开启，默认会解析<code>node_modules</code>的模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    cache: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// unsafeCache</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h2><p><code>resolve</code>的作用在于如何正确的识别模块，找到需要引入<code>bundle</code>的模块代码</p>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>创建别名，使得引入方式更加简单</p>
<p>也可以在给定对象的键后的末尾添加 <code>$</code>，以表示精准匹配</p>
<p>也可以使用 <code>{ &#39;路径&#39;: false }</code> 表示忽略路径的模块</p>
<blockquote>
<p>resolve.alias 优先级高于其它模块解析方式。 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Utilities: path.resolve(__dirname, <span class="string">'src/utilities/'</span>),</span><br><span class="line">      Templates: path.resolve(__dirname, <span class="string">'src/templates/'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原本方式</span></span><br><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'../../utilities/utility'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现阶段方式</span></span><br><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'Utilities/utility'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>优化，会根据打包模式自动切换配置，也可以手动配置</p>
<h3 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h3><p>开启表示需要压缩，需要配合 <code>TerserPlugin</code> 或其它在 <code>optimization.minimizer</code> 定义的插件压缩 <code>bundle</code></p>
<h3 id="minimizer"><a href="#minimizer" class="headerlink" title="minimizer"></a>minimizer</h3><p>使用自定义压缩工具，覆盖默认压缩工具，通常使用 <code>TerserPlugin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">        sourceMap: <span class="literal">true</span>, <span class="comment">// 如果在生产环境中使用 source-maps，必须设置为 true</span></span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          <span class="comment">// https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数形式，形参为 <code>compiler</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      (compiler) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line">        <span class="keyword">new</span> TerserPlugin(&#123; <span class="comment">/* 你的选项 */</span> &#125;).apply(compiler);</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h3><p>默认使用 <code>webpack4</code>默认的分块策略，具体手动配置参考 <a href="`https://webpack.docschina.org/plugins/split-chunks-plugin/`">splitChunkPlugin</a></p>
<h3 id="runtimeChunk"><a href="#runtimeChunk" class="headerlink" title="runtimeChunk"></a>runtimeChunk</h3><p><code>runtimeChunk</code>作用在于将只含有<code>runtime</code>的入口文件单独打包一个文件， 所谓<code>runtime</code>就是指异步加载代码如<code>import(&#39;./utils&#39;) =&gt; {}</code></p>
<h3 id="emitOnErrors"><a href="#emitOnErrors" class="headerlink" title="emitOnErrors"></a>emitOnErrors</h3><p>编译时每当有错误时，会被 <code>emit</code>， 关键错误会被 <code>emit</code> 到代码中</p>
<p>todo</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><h2 id="DevServer"><a href="#DevServer" class="headerlink" title="DevServer"></a>DevServer</h2><h2 id="Devtool"><a href="#Devtool" class="headerlink" title="Devtool"></a>Devtool</h2><h2 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h2><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><h2 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h2><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h2 id="stats对象"><a href="#stats对象" class="headerlink" title="stats对象"></a>stats对象</h2><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2>]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>重学Hooks——useEffect</title>
    <url>/2020/07/26/useEffect/</url>
    <content><![CDATA[<blockquote>
<p>Dan在OverReact上发表的文章深入浅出，本文只针对个人之前不理解的点进行思考，采用了他的案例，参考了他的文章——<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect的完整指南</a>.</p>
</blockquote>
<p>在我看来，Effect hook是React Hooks中最强大最核心的一个hook，是驱动整个程序的纽带我也将采用Dan的案例进行思考</p>
<hr>
<ul>
<li>根据文章问题，进行思考后，抛出了以下几个问题，将在下文对这几个问题做详细的思考<ol>
<li>Effect是如何进行渲染的?</li>
<li>如何用Effect模拟React的生命周期？<code>useEffect(fn,[])</code>和<code>componentDidMount</code>一样吗？</li>
<li>如何正确的使用Effect请求数据？</li>
<li>Effect的依赖到底用什么，可以用函数嘛，什么时候用函数作为依赖？</li>
<li>Effect Hook怎么会导致死循环？</li>
<li>Effect Hook怎么会拿到旧state和props，如果我真的想用旧的state和props，我应该怎么去获取？</li>
</ol>
</li>
</ul>
<a id="more"></a>

<h2 id="Effect到底是如何渲染的"><a href="#Effect到底是如何渲染的" class="headerlink" title="Effect到底是如何渲染的?"></a>Effect到底是如何渲染的?</h2><h3 id="渲染中state的渲染"><a href="#渲染中state的渲染" class="headerlink" title="渲染中state的渲染"></a>渲染中state的渲染</h3><ul>
<li>以下是最简单的点击次数加一的事件， 分析一下点击后数字的改变</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以下展示了count改变的来源，并非是通过事件监听或是事件绑定或是代理等对count本身做出的改变，而是<strong>重新创建了一个count</strong>， 新创建的count值是最后一次改变的state中的count.</p>
<table>
<thead>
<tr>
<th>点击次数</th>
<th>值</th>
<th>count来源</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>useState默认值</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>上一个useState的返回值</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>上一个useState的返回值</td>
</tr>
</tbody></table>
<p>代码体现则是如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// During first render</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; <span class="comment">// Returned by useState()</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ After a click, our function is called again</span></span><br><span class="line"><span class="regexp">function Counter() &#123;</span></span><br><span class="line"><span class="regexp">  const count = 1; /</span><span class="regexp">/ Returned by useState()</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;You clicked &#123;count&#125; times&lt;/</span>p&gt;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After another click, our function is called again</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; <span class="comment">// Returned by useState()</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因此发现，其实count只是一个常量，React在使用<code>setCount</code>后，带着一个新count再次调用组件!<blockquote>
<p>至于更深入的研究，还未研究过，准备参考Dan的另一篇文章<a href="https://overreacted.io/zh-hans/react-as-a-ui-runtime/" target="_blank" rel="noopener">将 React 作为 UI 运行时</a></p>
</blockquote>
</li>
</ul>
<!--more-->

<h3 id="渲染中事件处理函数的渲染"><a href="#渲染中事件处理函数的渲染" class="headerlink" title="渲染中事件处理函数的渲染"></a>渲染中事件处理函数的渲染</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们按照以下步骤做<ol>
<li>我先点击到按钮，使count到达1</li>
<li>点击show alert，再3秒内迅速点击按钮使count到3</li>
<li>观察alert的值， 值为1 or 3 ?? </li>
</ol>
</li>
</ul>
<p><a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">点我操作，看看到底是个啥</a></p>
<ul>
<li>根据上文，以下展示了这个调用的情况</li>
</ul>
<table>
<thead>
<tr>
<th>是否点击alert</th>
<th>此时点击次数</th>
<th>值</th>
<th>count来源</th>
<th>handleAlertClick</th>
</tr>
</thead>
<tbody><tr>
<td>否</td>
<td>0</td>
<td>0</td>
<td>useState默认值</td>
<td>handleAlertClick中的count取0</td>
</tr>
<tr>
<td>否</td>
<td>1</td>
<td>1</td>
<td>上一个useState的返回值</td>
<td>handleAlertClick中的count取1</td>
</tr>
<tr>
<td>是</td>
<td>1</td>
<td>1</td>
<td>上一个useState的返回值</td>
<td>handleAlertClick中的count取1</td>
</tr>
<tr>
<td>否</td>
<td>2</td>
<td>2</td>
<td>上一个useState的返回值</td>
<td>handleAlertClick中的count取2</td>
</tr>
<tr>
<td>否</td>
<td>3</td>
<td>3</td>
<td>上一个useState的返回值</td>
<td>handleAlertClick中的count取3</td>
</tr>
<tr>
<td>alert弹出</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>弹出表格对应的第三行的handleAlertClick</td>
</tr>
</tbody></table>
<ul>
<li>我们发现，每次调用的count和handleAlertClick，都是<strong>重新创建的<code>count</code>和<code>handleAlertClick</code></strong>，每次重新渲染组件，上一次的栈内存都将被释放。由于闭包，第一次的count并未被释放，而handleAlertClick被存放在了任务队列，记录的是没有被释放的count，哪怕点到了3，与之前的也没有任何关系，每次渲染都是<strong>独立</strong>的，因此值是1。</li>
</ul>
<p><em>每次渲染的state和props在渲染中是不会被改变的，因此每次渲染都是独立的，每次渲染的state和props都是不同的state和props。这种独立关系，再修改引用类型时，希望我们<code>setObject(newObject)</code>，这样可以保证上一个state不被污染</em></p>
<h4 id="问题1：Effect清理与浏览器渲染屏幕的执行顺序是什么样的呢？"><a href="#问题1：Effect清理与浏览器渲染屏幕的执行顺序是什么样的呢？" class="headerlink" title="问题1：Effect清理与浏览器渲染屏幕的执行顺序是什么样的呢？"></a>问题1：Effect清理与浏览器渲染屏幕的执行顺序是什么样的呢？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// First render, props are &#123;id: 10&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(</span><br><span class="line">    <span class="comment">// Effect from first render</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">      <span class="comment">// Cleanup for effect from first render</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ChatAPI.unsubscribeFromFriendStatus(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next render, props are &#123;id: 20&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(</span><br><span class="line">    <span class="comment">// Effect from second render</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      ChatAPI.subscribeToFriendStatus(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">      <span class="comment">// Cleanup for effect from second render</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        ChatAPI.unsubscribeFromFriendStatus(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照常理的逻辑，是这个顺序吗？？？？？？？</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>渲染props.id为10的UI</td>
</tr>
<tr>
<td>2</td>
<td>执行Effect，订阅数据</td>
</tr>
<tr>
<td>3</td>
<td>清除id为10的Effect</td>
</tr>
<tr>
<td>4</td>
<td>渲染props.id为20的UI</td>
</tr>
<tr>
<td>5</td>
<td>执行Effect，订阅数据</td>
</tr>
<tr>
<td>yes？？？？</td>
<td></td>
</tr>
<tr>
<td><strong>No</strong></td>
<td></td>
</tr>
</tbody></table>
<p>结果应该是如下的</p>
<table>
<thead>
<tr>
<th>次数</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>渲染props.id为10的UI</td>
</tr>
<tr>
<td>2</td>
<td>执行Effect，订阅数据</td>
</tr>
<tr>
<td>3</td>
<td>渲染props.id为20的UI</td>
</tr>
<tr>
<td>4</td>
<td>清除id为10的Effect</td>
</tr>
<tr>
<td>5</td>
<td>执行Effect，订阅数据</td>
</tr>
</tbody></table>
<p>因为Effect的执行一定是放在<strong>浏览器渲染屏幕</strong>之后的！因为每次渲染都是独立的，上一个Effect只能记住id为10的状态，因此，effect的清除并不会读取<strong>最新</strong>的<code>props</code>。它只能读取到定义它的那次渲染中的<code>props</code>值。</p>
<h4 id="问题2：每次渲染的Effect都是不同的Effect嘛？那么Effect中的state和外部state是什么关系？"><a href="#问题2：每次渲染的Effect都是不同的Effect嘛？那么Effect中的state和外部state是什么关系？" class="headerlink" title="问题2：每次渲染的Effect都是不同的Effect嘛？那么Effect中的state和外部state是什么关系？"></a>问题2：每次渲染的Effect都是不同的Effect嘛？那么Effect中的state和外部state是什么关系？</h4><p><strong>每次渲染的Effect都是不同的Effect</strong><br><strong>Effect中的state和props，都是特定的那次渲染的state和props</strong></p>
<h5 id="React执行Effect的时机是什么？"><a href="#React执行Effect的时机是什么？" class="headerlink" title="React执行Effect的时机是什么？"></a>React执行Effect的时机是什么？</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// console.log('effect外部被执行了')</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log('effect内部被执行了')</span></span><br><span class="line">        <span class="built_in">document</span>.title = count</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行顺序如下<ol>
<li>执行<code>const [count, setCount] = useState(0);</code></li>
<li>React记住Effect</li>
<li><strong>渲染dom</strong></li>
<li>调用<code>document.title = count</code></li>
</ol>
</li>
<li>因此我们要记住，<strong>Effect是在每次更改作用于DOM并让<em>浏览器绘制屏幕后</em>去调用它</strong></li>
</ul>
<h3 id="Effect中的异步"><a href="#Effect中的异步" class="headerlink" title="Effect中的异步"></a>Effect中的异步</h3><p>针对同步的情况，已经了解的差不多了，那么如果Effect中有延迟呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>假如我点击三次，将会打印什么，结论如下，原因很简单，因为每一个Effect中保存的是当前的count</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You clicked 0 times</span><br><span class="line">You clicked 1 times</span><br><span class="line">You clicked 2 times</span><br><span class="line">You clicked 3 times</span><br></pre></td></tr></table></figure>

<p>但是！上述工作机制与类并不相同，hooks写法中，每一个count是独立的，类写法中，将会输出一次<code>you clicked 0 times</code>和3次<code>you clicked 3 times</code>，原因是因为类写法中的count是同一个count</p>
<p><em>这原来就是困扰我好久好久的Effect中的闭包啊</em></p>
<h4 id="问题来了，如果我就想打印3次you-clicked-3-times怎么办"><a href="#问题来了，如果我就想打印3次you-clicked-3-times怎么办" class="headerlink" title="问题来了，如果我就想打印3次you clicked 3 times怎么办"></a>问题来了，如果我就想打印3次<code>you clicked 3 times</code>怎么办</h4><h5 id="ref登场"><a href="#ref登场" class="headerlink" title="ref登场"></a>ref登场</h5><ul>
<li>不同于class中的ref，hooks中的ref不仅可以保存dom元素，他可以作为<strong>任何值</strong>的容器<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> latestCount = useRef(count);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Set the mutable latest value</span></span><br><span class="line">    latestCount.current = count;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Read the mutable latest value</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;latestCount.current&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li>ok，这样就搞定啦，官网说了， <code>useRef</code>返回的对象，在<strong>整个生命周期内</strong>保持不变，因此不用担心每次创建的都是新的ref，这样我Effect函数中改变的ref内的容器值，都是同一个。</li>
<li>文章上半部分已经可以解决我们开篇提到的1、2、5、6三个问题<h2 id="Effect到底是怎么更新的？"><a href="#Effect到底是怎么更新的？" class="headerlink" title="Effect到底是怎么更新的？"></a>Effect到底是怎么更新的？</h2></li>
</ul>
<hr>
<h3 id="告诉React你要做什么样的比对"><a href="#告诉React你要做什么样的比对" class="headerlink" title="告诉React你要做什么样的比对"></a>告诉React你要做什么样的比对</h3><ul>
<li>我想关于这个依赖项，React文档做了更详尽的阐述。这里只拎几个点出来</li>
</ul>
<h4 id="类似于setState的函数式更新"><a href="#类似于setState的函数式更新" class="headerlink" title="类似于setState的函数式更新"></a>类似于setState的函数式更新</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于每次渲染都是独立的，我们知道，这里count永远都是1</li>
<li>解决方案如下：<ul>
<li>1、设置count作为依赖项<ul>
<li>虽然解决了问题，但是非常不好，代码如下，原因是因为每次修改count，都将重新生成一个定时器，useEffect都会被重新执行，这显然不是我们想要的结果</li>
</ul>
</li>
<li>2、函数式更新<ul>
<li>比较理想的解决方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置count为依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数式更新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种函数式更新，无需知道count的值，React已经知道，并将最新的count传递进去。成功将依赖项count移除</li>
</ul>
<p><strong>但是</strong></p>
<p>我不仅想要知道最新的count，我还想要知道最新的<code>props</code>或是其他的<code>state</code>。。（函数式更新凉凉）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>炸了，不是我们想要的</p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><ul>
<li>首先我们要知道，什么时候用这个useReducer？这里引用了React文档的内容。<blockquote>
<p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 <code>state</code> <strong>逻辑较复杂</strong>且包含多个子值，或者<strong>下一个 <code>state</code> 依赖于之前的 <code>state</code></strong> 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数。</p>
</blockquote>
</li>
</ul>
<p>这里默认已经会Redux了。</p>
<ul>
<li>关键点：<ul>
<li><ol>
<li>逻辑复杂</li>
</ol>
</li>
<li><ol start="2">
<li><strong>状态依赖</strong></li>
</ol>
</li>
<li><ol start="3">
<li>嵌套深的组件性能优化<br>其中第二点就是我们说的那一点，因此上面的案例可以改写为:</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">'tick'</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        dispatch(&#123;</span></span><br><span class="line"><span class="regexp">          type: 'step',</span></span><br><span class="line"><span class="regexp">          step: Number(e.target.value)</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp">      &#125;&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const initialState = &#123;</span></span><br><span class="line"><span class="regexp">  count: 0,</span></span><br><span class="line"><span class="regexp">  step: 1,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function reducer(state, action) &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; count, step &#125; = state;</span></span><br><span class="line"><span class="regexp">  if (action.type === 'tick') &#123;</span></span><br><span class="line"><span class="regexp">    return &#123; count: count + step, step &#125;;</span></span><br><span class="line"><span class="regexp">  &#125; else if (action.type === 'step') &#123;</span></span><br><span class="line"><span class="regexp">    return &#123; count, step: action.step &#125;;</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    throw new Error();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关键点： 用<code>dispatch</code>替代依赖(<strong><code>dispatch</code>会保证生命周期内保持不变</strong>)</li>
<li>这种模式的好处：通过<code>reducer</code>让我们不必再关心<code>state</code>和<code>props</code>的状态，成功达到了解耦的目的。</li>
</ul>
<p><em>但是问题来了，如果我每次都想获取最新的<code>props</code>，还有戏嘛？</em></p>
<p><strong>有的，把reducer扔组件里</strong></p>
<p>每次<code>dispatch</code>，都会调用<code>reducer</code>，这时候<code>reducer</code>获取的就是最新的<code>props</code>了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; step &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = useReducer(reducer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">'tick'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state + step;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">'tick'</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>难怪Dan说是Hooks的作弊模式</em></p>
<p><strong>接下来，我们着重解决第三和第四个问题</strong></p>
<h2 id="Effect中的数据请求"><a href="#Effect中的数据请求" class="headerlink" title="Effect中的数据请求"></a>Effect中的数据请求</h2><hr>
<p><strong>直接上案例</strong></p>
<p>这个模式曾经也是我在不是很懂Effect的情况下经常使用的模式，我曾经对<code>eslint-plugin-react-hooks</code>这个插件提供的警告存有很大的疑问，现在终于明白了。</p>
<p>乍一看？没问题！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Imagine this function is long</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query=react'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Imagine this function is also long</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(getFetchUrl());</span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>但是上述模式存在一个弊端，如果我们忘记写入依赖，那么我们的effects就不会同步props和state带来的变更。这当然不是我们想要的。</li>
</ul>
<p>我们把他放进去，前提是某些函数仅在effect中调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// We moved these functions inside!</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query=react'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(getFetchUrl());</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ Deps are OK</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是没问题吗？是的，没问题了。</p>
<p>稍微修改一下，使请求url中需要我们的状态，对，就是这么请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Imagine this function is also long</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Imagine this function is also long</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(getFetchUrl());</span><br><span class="line">      setData(result.data);</span><br><span class="line">    &#125;</span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我曾经有一次，在封装自定义Hook的时候，我将request提供给自定义hook，但是我却没法将我的state或者是props放进自定义hook，因为他们属于不同的js文件，这可怎么办？<br>说白了，就是逻辑复用咋搞。</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>这个Hook很简单，缓存一个函数，只在函数本身需要改变的时候调用副作用</p>
<p>怎么知道这个函数是否需要改变，通过第二个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SearchResults</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">'react'</span>);</span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'https://hn.algolia.com/api/v1/search?query='</span> + query;</span><br><span class="line">  &#125;, [query]);  <span class="comment">// ✅ Callback deps are OK</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'react'</span>);</span><br><span class="line">    <span class="comment">// ... Fetch data and do something ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// ✅ Effect deps are OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题解决！</p>
<p><em>Dan对<code>class</code>模式和<code>hooks</code>模式的这种网络请求没法放入依赖的情况分别作了比较，当request作为<strong>请求向下传递</strong>的情况。这里不细说了，class模式本身不是数据流的一部分，因此他必须将不必要的<code>query</code>传下去才能再<code>componentDidUpdate</code>中发生响应，而Hooks就完美的解决了这个问题</em></p>
<p><em>在我看来，useCallback就是一个工具人，我是老板，你没法直接跟我说话，就跟我秘书说。我秘书会传达给我的。</em></p>
<p>OK！1、2、3、4、5、6问题全都解决了！</p>
<h1 id="总结-amp-致谢"><a href="#总结-amp-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>前前后后通读了Dan的文章好多遍，并看了好几遍Effect的文档。初识Effect，似乎很简单，随着项目的锻炼，发现越来越难以管理自己的状态。花心思重新学了一下Effect。让我更清晰的明白了设计Hooks的初衷和目的，找到正确使用的姿势。</p>
<p>从阅读到完成，花了大概有半个月，主要参考资料来自Dan的Overreacted上的一篇文章useEffect完整指南。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>React运行时</title>
    <url>/2020/08/02/React-UI-render/</url>
    <content><![CDATA[<blockquote>
<p>Dan在OverReact上发表的文章深入浅出，本文只针对个人之前不理解的点进行思考，采用了他的案例，参考了他的文章——<a href="https://overreacted.io/zh-hans/react-as-a-ui-runtime/" target="_blank" rel="noopener">将 React 作为 UI 运行时</a>。</p>
</blockquote>
<blockquote>
<p>再写UI运行时的时候,发现一切都离不开Fiber,这里参考了掘金博主<em>武器大师1024</em>的一篇文章,并补充了一些他的案例<a href="https://juejin.im/post/6844903582622285831" target="_blank" rel="noopener">React Fiber</a>,同时,此案例也是<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark presentation in ReactConf 2017</a>演讲上的一篇案例。</p>
</blockquote>
<p>大多数人关注React，关注它的使用方法，关注它创建页面的逻辑和效果，而忽略其模型和React本质上的一些东西，到底React帮我们做了什么?</p>
<a id="more"></a>

<hr>
<h2 id="宿主树和宿主实例"><a href="#宿主树和宿主实例" class="headerlink" title="宿主树和宿主实例"></a>宿主树和宿主实例</h2><hr>
<h4 id="什么是宿主树，什么是宿主实例？"><a href="#什么是宿主树，什么是宿主实例？" class="headerlink" title="什么是宿主树，什么是宿主实例？"></a>什么是宿主树，什么是宿主实例？</h4><p>这是一个概念上的问题，区别两者，其实很简单，就像<strong>整体</strong>和<strong>局部</strong>的关系。例如一个Dom树，就是一个宿主树，Dom树中的一个<code>div</code>，就是一个宿主实例。</p>
<p>宿主实例有自己的属性和方法，我们可以操作宿主方法做一些想做的事情，例如<code>appendChild</code>，<code>setAttribute</code>等等</p>
<h4 id="React又是怎么利用宿主树和宿主实例的呢？"><a href="#React又是怎么利用宿主树和宿主实例的呢？" class="headerlink" title="React又是怎么利用宿主树和宿主实例的呢？"></a>React又是怎么利用宿主树和宿主实例的呢？</h4><p>在我看来，React的宿主树，是由其宿主实例构成的，而React的宿主实例，就是<strong>React元素</strong>，React元素是一个对象，与DOM树横向比对，大同小异，所以React再做UI渲染时，可以轻松的将其映射为对应的DOM元素，React经常帮我们做的，就是这个。</p>
<p>React解放了我们直接操作宿主树和宿主实例，因为React帮我们做了这个事情。做这些事情的同时，React又保证了另外两个事情:</p>
<ul>
<li><strong>稳定性</strong>: 宿主树的稳定性</li>
<li><strong>通用性</strong>：宿主树中的宿主实例单独抽出来，依旧不会改变其UI结构，达到可复用的状态</li>
</ul>
<h4 id="React操作宿主树和DOM有什么不同？"><a href="#React操作宿主树和DOM有什么不同？" class="headerlink" title="React操作宿主树和DOM有什么不同？"></a>React操作宿主树和DOM有什么不同？</h4><ul>
<li>DOM会导致突变，直接操作宿主实例。在之后往里面增加或者删除子节点。宿主实例是完全可变的。</li>
<li>React是通过克隆双亲树并始终替换掉顶级子树的宿主环境。</li>
</ul>
<h4 id="React的宿主实例——React元素"><a href="#React的宿主实例——React元素" class="headerlink" title="React的宿主实例——React元素"></a>React的宿主实例——React元素</h4><ul>
<li>React的元素不是永远存在的，他总是在<strong>重建</strong>和<strong>删除</strong>之间循环</li>
<li>你<strong>不能直接</strong>操作React元素(与DOM不同)，如果想改变，从头开始渲染</li>
</ul>
<h2 id="React渲染"><a href="#React渲染" class="headerlink" title="React渲染"></a>React渲染</h2><hr>
<h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><h4 id="初次调用"><a href="#初次调用" class="headerlink" title="初次调用"></a>初次调用</h4><p>看以下一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// &#123; type: 'button', props: &#123; className: 'blue' &#125; &#125;</span></span><br><span class="line">  &lt;button className=<span class="string">"blue"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>初始调用时，实际操作就是把你的宿主树转换成实际的dom树渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ReactDOM 渲染器内部（简化版）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHostInstance</span>(<span class="params">reactElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> domNode = <span class="built_in">document</span>.createElement(reactElement.type); <span class="comment">// 这里是button</span></span><br><span class="line">  domNode.className = reactElement.props.className; <span class="comment">// 这里是blue</span></span><br><span class="line">  <span class="keyword">return</span> domNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其放进dom</span></span><br><span class="line">domContainer.appendChild(domNode);</span><br></pre></td></tr></table></figure>

<h4 id="再次调用会如何做"><a href="#再次调用会如何做" class="headerlink" title="再次调用会如何做"></a>再次调用会如何做</h4><ul>
<li>想必看过React文档的都知道，会进行比对，只对需要更新的一部分进行更新，下面贴了Dan文章里的两段代码，简述了React的过程。但实际比对算法要复杂的多</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">"blue"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 之后 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应该替换掉 button 宿主实例吗？</span></span><br><span class="line"><span class="comment">// 还是在已有的 button 上更新属性？</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">"red"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>React工作流程大致如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let domNode = document.createElement('button');</span></span><br><span class="line"><span class="comment">// domNode.className = 'blue';</span></span><br><span class="line"><span class="comment">// domContainer.appendChild(domNode);</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">"blue"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能重用宿主实例吗？能！(button → button)</span></span><br><span class="line"><span class="comment">// domNode.className = 'red';</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;button className=<span class="string">"red"</span> /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能重用宿主实例吗？不能！(button → p)</span></span><br><span class="line"><span class="comment">// domContainer.removeChild(domNode);</span></span><br><span class="line"><span class="comment">// domNode = document.createElement('p');</span></span><br><span class="line"><span class="comment">// domNode.textContent = 'Hello';</span></span><br><span class="line"><span class="comment">// domContainer.appendChild(domNode);</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;p&gt;Hello&lt;<span class="regexp">/p&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('container')</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 能重用宿主实例吗？能！(p → p)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ domNode.textContent = 'Goodbye';</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Goodbye&lt;/</span>p&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里有个小注意点需要注意一下，当遇到条件语句时，React并不会重新创建元素，这依赖于元素的顺序，例如：这里的input始终在第二个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params">&#123; showMessage &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (showMessage) &#123;</span><br><span class="line">    message = &#123;</span><br><span class="line">      type: <span class="string">'p'</span>,</span><br><span class="line">      props: &#123; <span class="attr">children</span>: <span class="string">'I was just added here!'</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'dialog'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      children: [</span><br><span class="line">        message,</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">'input'</span>, <span class="attr">props</span>: &#123;&#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的小注意点引申出，当遇到列表时，React会去比对元素，如果<strong>元素相同</strong>，那么<strong>直接复用</strong>。问题是，当我们遇到类似于商品列表时，商品列表往往各项都不相同，或者说一个列表中有几项相同，那么React该怎么办，如果还是按照顺序来，那每个元素都将被更新。</p>
<p>这样导致的问题是，每个元素更新，消耗性能。同时，React会把类似于input这样的组件当时的值一并复用过来，导致潜在的bug。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ShoppingList</span>(<span class="params">&#123; list &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &#123;list.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          You bought &#123;item.name&#125;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          Enter how many <span class="keyword">do</span> you want: <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React将会以以下的形式更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> pNode = formNode.childNodes[i];</span><br><span class="line">  <span class="keyword">let</span> textNode = pNode.firstChild;</span><br><span class="line">  textNode.textContent = <span class="string">'You bought '</span> + items[i].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因此我们需要一个唯一标识key，来告诉React渲染前后元素是否是相同的。</li>
</ul>
<p><em>组件和元素大同小异，React也会递归组件，渲染想要的元素。组件首字母必须大写，为了让React区分，告诉它这是一个组件而不是一个dom元素</em></p>
<p><em>补充两个小点</em></p>
<ul>
<li><p>什么是Hooks？</p>
<ul>
<li>其实Hooks是绑定组件局部状态的特性。</li>
</ul>
</li>
<li><p>什么是局部状态</p>
<ul>
<li>局部状态是宿主实例相关的能拥有的状态，例如focus、selection等等。</li>
</ul>
</li>
</ul>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>组件是函数，为什么不用函数调用，而用JSX的形式呢？</p>
<ul>
<li>我们自身调用函数，控制权在我们手里，用JSX的形式，React会为我们调用函数，这就是控制反转。使用控制反转有以下几个好处：<ul>
<li><strong>组件 &gt; 函数</strong> React组件帮助我们维护了局部状态</li>
<li><strong>组件参与协调</strong> 也就是说React调用组件，可以更了解宿主树的结构，便于进行比对</li>
<li><strong>组件推迟协调</strong> 不会引起渲染导致的主线程阻塞</li>
<li><strong>组件便于调试</strong> React提供了丰富的组件调试工具</li>
<li><strong>组件可以懒加载</strong> 组件不会去执行不需要执行的东西，例如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">&#123; currentUser, children &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!currentUser.isLoggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Layout&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 这里有个地方调用组件</span></span><br><span class="line"><span class="regexp">&lt;Page&gt;</span></span><br><span class="line"><span class="regexp">    &#123;Comments()&#125; /</span><span class="regexp">/ 这个Comments函数无论是否登录永远都将执行</span></span><br><span class="line"><span class="regexp">&lt;/</span>Page&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有个地方调用组件</span></span><br><span class="line">&lt;Page&gt;</span><br><span class="line">    &lt;Comments /&gt; <span class="comment">// 这个Comments组件</span></span><br><span class="line">&lt;<span class="regexp">/Page&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="渲染阶段-React-Fiber-和提交阶段"><a href="#渲染阶段-React-Fiber-和提交阶段" class="headerlink" title="渲染阶段(React Fiber)和提交阶段"></a>渲染阶段(<code>React Fiber</code>)和提交阶段</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidUpdate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            &lt;button key=<span class="string">"1"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Update counter&lt;<span class="regexp">/button&gt;,</span></span><br><span class="line"><span class="regexp">            &lt;span key="2"&gt;&#123;this.state.count&#125;&lt;/</span>span&gt;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>什么是Fiber？为什么使用Fiber？看以下的图:</p>
<p><img src="stack-reconciler" alt=""></p>
<p><img src="Fiber-reconciler" alt=""></p>
<p><code>React 16</code>版本之前，<code>React</code>完全通过<code>stack reconciler</code>进行比对(见图1)，这种比对会在<code>setState</code>进行后立即发生，会递归函数，当<code>vDom</code>遍历完成之后，得到对应的真实Dom的信息，并传递给<code>render</code>进行渲染。如果有大量的比对，那么会<strong>消耗过长的时间</strong>，浏览器线程此时被js代码所<strong>阻塞</strong>，如果遇到类似于动画效果，那么动画效果将被延迟执行，不仅如此，交互布局都将被阻塞，给用户的感觉就是卡顿的感觉。</p>
<p><img src="stack-workflow" alt=""></p>
<p>上述图片展示了<code>stack</code>工作时的内存情况，因此，<code>React</code>重写了其算法，使用了<code>Fiber</code>。</p>
<h4 id="Schedule-调度"><a href="#Schedule-调度" class="headerlink" title="Schedule(调度)"></a>Schedule(调度)</h4><p>调度是什么？—— 调度就是调动，安排人力，车辆。(来自百度百科)</p>
<p>我们已经知道<code>stack reconciler</code>模式的弊端，比对占用大量时间，阻塞了主线程。因此，我们需要有人安排，何时能够进行比对。这种调度是<code>Fiber reconciler</code>中的过程之一，如果浏览器主线程的优先级高，那么我们优先进行浏览器想要进行的操作。类似于下图。</p>
<p><img src="Fiber-workflow" alt=""></p>
<p>如上图所示，我们需要达成此目的，我们需要拆分我们的宿主树，拆分成一个个<strong>片段</strong>，以链表的形式，为每个节点添加一些必要的数据结构，来达成连续的片段。并且这些连续的片段可以被高优先级的任务随时中断。</p>
<p>这样引发一个问题，真实<code>Dom</code>与我当前的<code>vDom</code>不一致(由于我可能已经更新了一些片段)，因此，调度过程中，我们必须保存我们的调度信息，除了当前正在比对的树(current树)。我们还需要维护一棵正在比对的树，这棵树保存的是已经比对过的片段(workInProgress树)。</p>
<h5 id="怎么和浏览器进行通信，何时和浏览器进行通信呢"><a href="#怎么和浏览器进行通信，何时和浏览器进行通信呢" class="headerlink" title="怎么和浏览器进行通信，何时和浏览器进行通信呢?"></a>怎么和浏览器进行通信，何时和浏览器进行通信呢?</h5><p>客户端执行任务按帧来计算，通常执行帧在30~60帧之间。在两个执行帧之间的空闲时间，通常被用来进行调度，执行任务。</p>
<p><img src="requestIdelCallback" alt=""></p>
<p>如上图所示，浏览器可以在这两个空闲期之间执行<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener"><code>requestIdleCallback</code></a>，浏览器同时也会传递给回调函数<code>deadline</code>相关的对象信息，如果说你这个<code>fiber node</code>执行时间过长，这个<code>fiber node</code>依旧会执行完才会去向浏览器征求意见，如果说你这个里面写了个死循环，那么页面将会卡死，通常一个<code>fiber node</code>不会超过16ms，超过了则将出现卡顿的情况。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><blockquote>
<p>这个例子借用React Conf 2017上Lin Clark的演讲(<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs&list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0&index=6&t=0s" target="_blank" rel="noopener">附上链接</a>)</p>
</blockquote>
<p>现在有一个列表，渲染一个<code>button</code>和一组<code>item</code>, <code>item</code>中包含一个<code>div</code>，其中的内容为数字。通过点击<code>button</code>，可以使列表中的所有数字进行平方。另外有一个按钮，点击可以调节字体大小。</p>
<p><img src="demo-0" alt=""></p>
<p>1.0 页面初始化完成，渲染一个<code>fiber tree</code>，如下图所示</p>
<p><em>这里注意：每个<code>fiber node</code>，<code>child</code>指针指向的节点都为其直接子节点，至于其他子节点，将会由直接子节点的<code>sibling</code>指针指向，具体可见<code>fiber</code>数据结构，每个<code>fiber node</code>都向其父节点返回</em></p>
<p><img src="demo-0.1" alt=""></p>
<p>1.0.1 React同时维护用于计算更新，保存当前计算状态的树，称之为<code>workInProgressTree</code>，。</p>
<p><img src="demo-0.2" alt=""></p>
<p>1.1 用户点击平方操作，调用<code>setState</code>，<code>React</code>将其送入更新队列(<code>update queue</code>), 不会立即进行对比，修改<code>dom</code>，而是交给调度器(<code>scheduler</code>)</p>
<p><img src="demo-0.3" alt=""></p>
<p>1.2 调度器会去询问主线程的使用情况，上文已经描述了如何与浏览器进行通信，借用<code>requestIdelCallback</code>，根据优先级执行任务，低优先级通过<code>requestIdelCallback</code>，高优先级(动画)通过<code>requestAnimationFrame</code>执行。</p>
<p><img src="requestIdelCallback" alt=""></p>
<p>2.1 一旦调度器得到了时间，就开始进入了<code>work loop</code>，这种循环是等待与执行的循环，每次<code>fiber node</code><strong>执行完成</strong>才会去询问浏览器主线程状态，上文说了，通常是在16ms之内完成，否则会有卡顿情况，如果写了死循环，依旧会导致页面卡死的情况。在这个过程中，当前的<code>fiber node</code>需要记住下一个工作单元，如果浏览器有时间，那么我将进行下一个<code>fiber node</code>的任务执行</p>
<p><img src="demo-1" alt=""></p>
<p>2.2 根节点上的更新队列为空，所以直接从<code>fiber-tree</code>上将根节点复制到<code>workInProgressTree</code>中去。根节点中包含指向子节点<code>List</code>的指针。</p>
<p><img src="demo-2" alt=""></p>
<p>2.3 根节点根据child指针，将<code>List</code>节点和对应的更新队列一起放到<code>workInProgressTree</code>中，<code>List</code>插入后返回给父节点，标志着根节点<code>fiber node</code>处理完成</p>
<p><img src="demo-3" alt=""></p>
<p>2.4 重复1.2操作，询问主线程情况</p>
<p><img src="demo-4" alt=""></p>
<p>3.1 处理下一个<code>List</code>节点，进入<code>work loop</code>，因此此时<code>react</code>会调用<code>setState</code>时传入的<code>updater funciton</code>获取最新的state值，此时应该是<code>[1,4,9]</code></p>
<ul>
<li>在继续之前，我们简单回顾一下<code>setState</code>的前几步流程:<ul>
<li>触发<code>setState</code>函数，将触发<code>setState</code>的<code>this</code>和<code>setState</code>的参数传入<code>enqueueSetState</code>函数中。</li>
<li><code>enqueueSetState</code>函数，提出当前触发<code>setState</code>的<code>Fiber</code>节点并将传入的<code>setState</code>的参数创建一个<code>update</code>对象，<code>update</code>对象中的<code>payload</code>就是传入的<code>state</code>对象。</li>
<li><code>enqueueUpdate</code>函数，将当前<code>Fiber</code>的<code>state</code>和需要修改的<code>state</code>创建一个对象传入当前<code>Fiber</code>节点的<code>updateQueue</code>对象中。<code>updateQueue</code>对象有几个关键值，<code>baseState</code>(当前<code>Fiber</code>节点的<code>state</code>)、<code>firstUpdate</code>(首个更新任务)、<code>lastUpdate</code>(最后一个更新任务，防止多次重复<code>setState</code>)。</li>
</ul>
</li>
</ul>
<p>在获取到最新的<code>state</code>值后，<code>react</code>会更新<code>List</code>的<code>state</code>和<code>props</code>值，并且根据<code>element</code>类型判断是否可重用，然后渲染到<code>workInProgress</code>树中，由于<code>List</code>组件有更新，因此我们需要将<code>List</code>打上标签，表明需要更新。</p>
<p><img src="demo-5" alt=""></p>
<p>3.2 重复1.2操作，询问主线程情况</p>
<p><img src="demo-6" alt=""></p>
<p>3.3 <code>button</code>没有子节点，也没有更新，因此直接标记<code>button</code>处理完成。</p>
<p><img src="demo-7" alt=""></p>
<p>3.4 重复1.2操作，询问主线程情况。由于我们点击了放大字体的操作，主线程已经有放大字体的操作在等待<code>fiber node</code>任务完成。</p>
<p><img src="demo-8" alt=""></p>
<p>3.5 对于每一个<code>item</code>,判断<code>shouldComponentUpdate</code>,如果不需要更新，那么我们像3.3中的<code>button</code>一样操作，如果需要更新，那么我们像3.1中的<code>List</code>一样操作，打需要更新的标签</p>
<p><img src="demo-9" alt=""></p>
<p>4.1 对于叶子节点<code>div</code>，无兄弟节点，更新操作也已结束，需要合并到父节点，才算<code>fiber node</code>完成。</p>
<p><img src="demo-10" alt=""></p>
<p>4.2 合并回到父节点，并移除标签，标记完成。</p>
<p><img src="demo-11" alt=""></p>
<p>4.3 重复1.2操作，询问主线程情况。现在有放大字体的操作在等待。因此交换主线程，放大字体。</p>
<p><img src="demo-12" alt=""></p>
<p>4.4 放大字体完成，<code>React</code>完成接下来的操作，形成一个完成的<code>workInProgress</code>树。</p>
<p><img src="demo-13" alt=""></p>
<p>4.5 那些更新的<code>item</code>向<code>List</code>返回, 标签列表如下</p>
<p><img src="demo-14" alt=""></p>
<p>4.6 所有节点标记完成后,<code>React</code>正式进入提交阶段,同样询问主线程,时间够用,更新<code>Dom</code></p>
<p><img src="demo-15" alt=""></p>
<p>4.7 更新完过后还需要交换指针</p>
<p><img src="demo-16" alt=""></p>
<h4 id="废除生命周期"><a href="#废除生命周期" class="headerlink" title="废除生命周期"></a>废除生命周期</h4><ul>
<li>为什么<code>Fiber Reconciler</code>下, <code>React</code>要废除生命周期例如<code>componentWillUpdate</code>?</li>
</ul>
<p>我们通过刚刚<code>Fiber Reconciler</code>的过程我们看到, 这个过程是可以被高优先级例如动画所打断的, 我们初次调用<code>componentWillUpdate</code>, 结果我<code>Reconciler</code>到一半,被打断了, 当主线程又有时间的时候,我又要进行<code>componentWillUpdate</code>,显然是不合理的.</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>发票匹配2.0技术设计</title>
    <url>/2022/02/21/%E5%85%AC%E5%8F%B8%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1-%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><h3 id="组件结构图"><a href="#组件结构图" class="headerlink" title="组件结构图"></a>组件结构图</h3><ul>
<li>父： 发票列表页 InvoiceListModal</li>
<li>父： 发票明细匹配情况(未匹配 和 已匹配) InvoiceMatch<ul>
<li>子：NeedManualMatchTable（未匹配列表）</li>
<li>子：InvoiceMatchedTable （已匹配列表）</li>
</ul>
</li>
<li>父：手动匹配 InvoiceManualMatch <ul>
<li>子：SoureceManualMatchTable（单据明细列表）</li>
<li>子：InvoiceManualMatchTable （发票明细列表）</li>
</ul>
</li>
<li>父： 用户待确认明细 InvoiceUniqueness<ul>
<li>子：ConfirmManualMatchTable （待确认单据列表）</li>
<li>子：InvoiceManualMatchTable （待确认发票明细列表）</li>
</ul>
</li>
</ul>
<p><img src="%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D2.0%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt=""></p>
<a id="more"></a>

<h3 id="组件数据交互流图"><a href="#组件数据交互流图" class="headerlink" title="组件数据交互流图"></a>组件数据交互流图</h3><h4 id="虚线代表数据传输-实线代表实际交互流程"><a href="#虚线代表数据传输-实线代表实际交互流程" class="headerlink" title="虚线代表数据传输 实线代表实际交互流程"></a><code>虚线代表数据传输 实线代表实际交互流程</code></h4><h4 id="方框代表组件-对应上图组件-数据结构"><a href="#方框代表组件-对应上图组件-数据结构" class="headerlink" title="方框代表组件(对应上图组件) / 数据结构"></a>方框代表组件(对应上图组件) / 数据结构</h4><h4 id="菱形代表数据处理-用户动作-判断条件"><a href="#菱形代表数据处理-用户动作-判断条件" class="headerlink" title="菱形代表数据处理 / 用户动作 / 判断条件"></a>菱形代表数据处理 / 用户动作 / 判断条件</h4><h4 id="气泡框代表解释"><a href="#气泡框代表解释" class="headerlink" title="气泡框代表解释"></a>气泡框代表解释</h4><p>主要设计思想：</p>
<ol>
<li>所有数据初始化过后不再进行修改，直接有用的参数全部挂在发票对象上</li>
<li>对应发票匹配的单据挂发票上，<code>发票明细匹配的单据挂发票明细上</code>，多对多匹配的用groupId确认分组</li>
<li>可逆操作的数据全都使用备份</li>
<li>共同数据全部使用全局数据管理</li>
<li>容差在需要的顶层配置好，把对应配置项传下去根据配置数据结构直接渲染</li>
</ol>
<p><img src="%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D2.0%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt=""></p>
<h3 id="发票redux数据模型设计"><a href="#发票redux数据模型设计" class="headerlink" title="发票redux数据模型设计"></a>发票redux数据模型设计</h3><p>核心是高阶reducer的复用以及业务action的拆分</p>
<ul>
<li>高阶reducer好处1：同样的单据集的处理不用处理多套</li>
<li>高阶reducer好处2：对于备份的发票和单据，也可以复用对应的处理方式(useReducer)</li>
<li>action拆分好处：action不但可以用于生成新的全局state，还可以用于普通单据的增删改</li>
</ul>
<p><img src="redux%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt=""></p>
<h3 id="容差设计"><a href="#容差设计" class="headerlink" title="容差设计"></a>容差设计</h3><h4 id="顶层根据配置返回如下结构"><a href="#顶层根据配置返回如下结构" class="headerlink" title="顶层根据配置返回如下结构"></a>顶层根据配置返回如下结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      [MONEY_MATCH_SETTING.AMOUNT_INCLUDED_TAX]: &#123;</span><br><span class="line">           isOpen, <span class="comment">// 存是否被打开了</span></span><br><span class="line">           usedOffset, <span class="comment">// 发票已经被占用的容差, 这里的可用容差都是针对发票的</span></span><br><span class="line">           isStrength, <span class="comment">// 强校验还是弱校验</span></span><br><span class="line">           isExceed, <span class="comment">// 是否超出容差值</span></span><br><span class="line">           tailing, <span class="comment">// 设置的容差值</span></span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后续对容差的操作直接通过 invoiceUtil.js 下对应的容差方法修改</li>
<li>所有操作都是基于此数据结构（计算和渲染），如有可逆操作将此结构备份</li>
</ul>
<h3 id="强弱校验设计"><a href="#强弱校验设计" class="headerlink" title="强弱校验设计"></a>强弱校验设计</h3><p><strong>强弱校验相关的全部基于以下二进制进行操作</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NoStatus = <span class="comment">/*                    */</span> <span class="number">0b00000000000000000000000000</span>; <span class="comment">// 不校验</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IgnoreStatus = <span class="comment">/*                */</span> <span class="number">0b00000000000000000000000001</span>; <span class="comment">// 校验通过</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> WarningStatus = <span class="comment">/*               */</span> <span class="number">0b00000000000000000000000010</span>; <span class="comment">// 弱通过</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ForbiddenStatus = <span class="comment">/*             */</span> <span class="number">0b00000000000000000000000100</span>; <span class="comment">// 强通过</span></span><br></pre></td></tr></table></figure>

<p><strong>以强校验举例</strong></p>
<ul>
<li>初始化为 NoStatus，如果遇到了某强校验， 则使用 <code>NoStatus |  ForbiddenStatus</code></li>
<li>判断某校验是否为强校验(假设此变量x的二进制为ForbiddenStatus), 则：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(x &amp; ForbiddenStatus) !== NoStatus  代表变量x是强校验</span><br></pre></td></tr></table></figure></li>
<li>通常后端会返回对应好字段 <code>&quot;FORBIDDEN&quot;</code>、<code>&quot;WARNING&quot;</code>、<code>&quot;IGNORE&quot;</code>，invoiceUtil做好映射如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> resultStringMapStatus = &#123;</span><br><span class="line">    <span class="string">'FORBIDDEN'</span>: ForbiddenStatus,</span><br><span class="line">    <span class="string">'WARNING'</span>: WarningStatus,</span><br><span class="line">    <span class="string">'IGNORE'</span>: IgnoreStatus,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>针对匹配错误相关的映射，invoiceUtil文件下做好映射如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[errorCode/matchStatus]: &#123;</span><br><span class="line">  text: <span class="string">'错误提示文字'</span>,</span><br><span class="line">  status: ForbiddenStatus,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="前端对测试的减负点："><a href="#前端对测试的减负点：" class="headerlink" title="前端对测试的减负点："></a>前端对测试的减负点：</h4><ul>
<li>现<code>容差</code>整体顶层配置，只需要详细测一个纬度即可，其他纬度挑一个点测</li>
<li>发票<code>手动匹配流程</code>只需要测一个纬度就行，其他纬度挑一个情况测</li>
<li>抬头联动的测试，只需要测 <code>有强有弱/无强有弱/无强无弱</code> 三种情况，分别是 <code>红/黄/白</code>，现逻辑都是有红则红，没红有黄则黄， 都没有则白</li>
</ul>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><h4 id="产品设计对前端的影响点："><a href="#产品设计对前端的影响点：" class="headerlink" title="产品设计对前端的影响点："></a>产品设计对前端的影响点：</h4><ul>
<li>不要让前端在发票列表页计算容差，影响性能（有些发票相关信息未必是发票上直接获取，需要去累加发票明细，如数量）。目前卡死在发票明细匹配情况页面，</li>
<li>减少跨发票的操作（所有操作都是A发票的，操作完修改另一张发票匹配的相关数据），实现成本极大</li>
<li>设计时减少跨级操作，例如：发票列表页直接跳过发票明细匹配情况页面，直接进入手动匹配页面，属于比较特殊的代码（目前有且只有未验真可以有如此操作），会让前端代码变得复杂难以维护</li>
<li>尽可能按照组件结构图的流程走，匹配流程不要再整体的匹配过程中插入新的页面</li>
</ul>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手搭建一个React应用程序</title>
    <url>/2021/01/10/%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>本应用程序为<code>webpack5.0</code> + <code>React17</code> + <code>antd4.x</code></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><h4 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h4><p>我们使用<code>npm</code>先创建一个<code>package.json</code>, 安装<code>webpack</code>&nbsp;&nbsp;&nbsp;  <code>webpack-cli</code> &nbsp;&nbsp;&nbsp;<code>react</code> &nbsp;&nbsp;&nbsp; <code>react-dom</code> &nbsp;&nbsp;&nbsp; <code>react-router-dom</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">yarn add webpack webpack-cli --dev</span><br><span class="line"></span><br><span class="line">yarn add react react-dom react-router-dom</span><br></pre></td></tr></table></figure>

<p>根目录创建<code>webpack.config.js</code>(暂时只考虑<strong>开发环境</strong>)</p>
<p>根目录下创建<code>app</code>文件夹作为我们的应用程序主入口,入口文件为<code>app.js</code></p>
<p>项目结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─ app</span><br><span class="line">   |-app.js</span><br><span class="line">├─ node_modules</span><br><span class="line">    |- ......</span><br><span class="line">├─ webpack.config.js</span><br><span class="line">└─ package.json</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="配置基本webpack"><a href="#配置基本webpack" class="headerlink" title="配置基本webpack"></a>配置基本webpack</h4><p>这里我们配置一些基本的<code>webpack</code>打包必须的配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123; </span><br><span class="line">      index: &#123;</span><br><span class="line">        <span class="keyword">import</span>: <span class="string">'/app/app.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].[contenthash].bundle.js'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'[name].[id].js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h4><p>我们需要解析模块, 生成<code>bundle</code>, 这里我们使用<code>babel-loader</code>来转换js, <code>less-loader</code> &nbsp;&nbsp;&nbsp; <code>css-loader</code> &nbsp;&nbsp;&nbsp; <code>style-loader</code>来加载样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add less less-loader --dev</span><br><span class="line">yarn add babel-loader --dev</span><br><span class="line">yarn add css-loader style-loader --dev</span><br></pre></td></tr></table></figure>
<!--more-->

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123; </span><br><span class="line">      index: &#123;</span><br><span class="line">        <span class="keyword">import</span>: <span class="string">'/app/app.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].[contenthash].bundle.js'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'[name].[id].js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">'app'</span>),</span><br><span class="line">            use: &#123;</span><br><span class="line">              loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于用到了<code>babel</code>转换<code>js</code>,我们需要装一些<code>babel</code>的核心模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core @babel/cli @babel/preset-env --dev</span><br></pre></td></tr></table></figure>

<h4 id="添加调试基础插件"><a href="#添加调试基础插件" class="headerlink" title="添加调试基础插件"></a>添加调试基础插件</h4><p>接下来装一些便于我们调试的基础插件<code>html-webpack-plugin</code> &nbsp;&nbsp;&nbsp;<code>clean-webpack-plugin</code> &nbsp;&nbsp;&nbsp;<code>webpack-manifest-plugin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin clean-webpack-plugin webpack-manifest-plugin --dev</span><br></pre></td></tr></table></figure>

<p>创建模板<code>index.html</code>, 并添加插件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>起步<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; WebpackManifestPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123; </span><br><span class="line">      index: &#123;</span><br><span class="line">        <span class="keyword">import</span>: <span class="string">'/app/app.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].[contenthash].bundle.js'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'[name].[id].js'</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      contentBase: <span class="string">'/dist'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">            include: path.resolve(__dirname, <span class="string">'app'</span>),</span><br><span class="line">            use: &#123;</span><br><span class="line">              loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/i</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        inject: <span class="literal">true</span>,</span><br><span class="line">        template: <span class="string">'/app/index.html'</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> WebpackManifestPlugin()</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h4><p>新建本地服务, 添加模块热更新, 这里我们使用<code>Express</code>启动服务</p>
<p>我们在根目录创建一个<code>server</code>的文件夹, 创建一个<code>index.js</code>文件, 编写我们的启动脚本</p>
<p>这里我们需要安装<code>webpack-dev-server</code> &nbsp;&nbsp;&nbsp; <code>webpack-dev-middleware</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add express</span><br><span class="line">yarn add webpack-dev-server --dev</span><br><span class="line">yarn add webpack-dev-middleware --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /server/index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告知 express 使用 webpack-dev-middleware，</span></span><br><span class="line"><span class="comment">// 以及将 webpack.config.js 配置文件作为基础配置。</span></span><br><span class="line">app.use(</span><br><span class="line">  webpackDevMiddleware(compiler, &#123;</span><br><span class="line">    publicPath: config.output.publicPath,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件 serve 到 port 3000。</span></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!\n'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>webpack.config.js</code>文件添加<code>contentBase</code>,表明从哪里去寻找文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// dist为我们的输出目录</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="编写启动脚本"><a href="#编写启动脚本" class="headerlink" title="编写启动脚本"></a>编写启动脚本</h4><p>我们在<code>package.json</code>中编写一些脚本,便于我们启动服务和打包</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webpack --config webpack.config.js",</span><br><span class="line">    "start": "node server/index.js"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这时候基本的需要已经搭建完成, 我们在<code>app.js</code>中随便写点东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<p><img src="webpack%E5%90%AF%E5%8A%A8.png" alt=""><br><img src="%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2.png" alt=""></p>
<h3 id="解析jsx"><a href="#解析jsx" class="headerlink" title="解析jsx"></a>解析jsx</h3><p>到此为止我们已经可以正确打包js文件, 正确启动脚本, 安装了应用程序一些必要的依赖, 但是我们还无法解析<code>jsx</code>语法</p>
<p>如果我们在app.js文件中写如下代码, 启动或编译</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>111<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>
<p>我们会看到如下报错<br><img src="jsx%E6%8A%A5%E9%94%99.png" alt=""></p>
<p>因此我们需要安装<code>babel</code>转换jsx相关的插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-react --dev</span><br></pre></td></tr></table></figure>

<p>按照<code>babel</code>官网的教程,在根目录下创建<code>babel.config.json</code></p>
<p>此时项目结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─ app</span><br><span class="line">   |-app.js</span><br><span class="line">├─ node_modules</span><br><span class="line">    |- ......</span><br><span class="line">├─ server</span><br><span class="line">    ├─ index.js</span><br><span class="line">├─ webpack.config.js</span><br><span class="line">├─ babel.config.json</span><br><span class="line">└─ package.json</span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure>

<p>在这里我们配一些基础的 <code>js</code> 转换的预设, 这里包括一个解析 <code>jsx</code> 的<code>babel</code>预设,一个<code>js</code>转换的预设, 这里 <code>module</code> 设置为 <code>false</code> 是根据当前的调用者判断其已经支持ES6模块语法，则默认的auto将自动选择<code>false</code>，否则将选择 <code>commonjs</code>, 这里手动设置为 <code>false</code> 将不支持将 <code>ES6</code> 模块语法转换为其他模块类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">"@babel/env"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">          <span class="attr">"module"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      [<span class="string">"@babel/preset-react"</span>, </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"development"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意,<code>babel</code> 中<code>preset</code>顺序是从后往前执行,<code>plugin</code>的顺序是从后往前执行</p>
<p>再次打包后成功<br><img src="babel%E8%A7%A3%E6%9E%90jsx.png" alt=""></p>
<p>我们启动下试试看<br><img src="babel%E8%BD%AC%E6%8D%A2jsx%E6%88%90%E5%8A%9F" alt=""></p>
<p>同样, 使用<code>class</code>的写法也能正确解析, 这里有个注意点, 针对类, 我们需要使用<code>@babel/plugin-proposal-class-properties</code>,否则如下代码无法编译</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我说话了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add @babel/plugin-proposal-<span class="class"><span class="keyword">class</span>-<span class="title">properties</span> --<span class="title">dev</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">"@babel/env"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">          <span class="attr">"module"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      [<span class="string">"@babel/preset-react"</span>, </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"development"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="attr">"loose"</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装antd"><a href="#安装antd" class="headerlink" title="安装antd"></a>安装antd</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add antd</span><br></pre></td></tr></table></figure>
<p>我们修改<code>app.js</code>,导入<code>antd</code>的<code>Button</code>看看效果如何</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            buttonText: <span class="string">"我是按钮"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>&#123;this.state.buttonText&#125;<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyDemo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>))</span><br></pre></td></tr></table></figure>
<p>结果是确实引入了<code>antd</code>的组件,但是并未引入<code>antd</code>的样式</p>
<p>我们选择使用<code>babel</code>动态导入的方法引入样式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add babel-plugin-import --dev</span><br></pre></td></tr></table></figure>

<p>然后修改<code>babel.config.json</code>配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">"@babel/env"</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">          <span class="attr">"modules"</span>: <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      [<span class="string">"@babel/preset-react"</span>, </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"development"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="attr">"loose"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"libraryDirectory"</span>: <span class="string">"es"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="antd%E6%A0%B7%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%88%90%E5%8A%9F.png" alt=""></p>
<h3 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h3><p>为了确保项目需要, 我们保持<code>ie10</code>及以上的兼容, <code>babel</code>会根据配置文件的<code>target</code>, <code>package.json</code>, 根目录<code>browserslist</code>依次去寻找浏览器版本.这里我们在 <code>package.json</code> 中配置 <code>browerslist</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"browserslist": [</span><br><span class="line">    "last 1 version",</span><br><span class="line">    "&gt; 1%",</span><br><span class="line">    <span class="string">"IE 10"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>运行 <code>npx browerslist</code>得到如下图</p>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.png" alt=""></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>初探CKEditor5</title>
    <url>/2022/04/20/%E5%88%9D%E6%8E%A2CKEditor5/</url>
    <content><![CDATA[<h2 id="选择的原因"><a href="#选择的原因" class="headerlink" title="选择的原因"></a>选择的原因</h2><p>这里将<code>wangEditor5</code>与<code>CkEditor5</code>作为比较</p>
<ul>
<li>CkEditor优势 <ol>
<li>文档详细</li>
<li>用户量大</li>
<li>自定义插件扩展非常容易</li>
</ol>
</li>
<li>CkEditor劣势 <ol>
<li>纯英文文档，无翻译</li>
<li>未解决的_issues_尚且较多</li>
</ol>
</li>
</ul>
<h3 id="npm月下载量比较"><a href="#npm月下载量比较" class="headerlink" title="npm月下载量比较"></a>npm月下载量比较</h3><p><code>CKEditor</code>月下载量如下图所示：<br><img src="ckeditor-using-quantity.png" alt="ckeditor-using-quantity.png"></p>
<p><code>wangEditor</code>月下载量如下图所示：<br><img src="wang-editor-using-quantity.png" alt="wang-editor-using-quantity.png"></p>
<p>结论：<code>CKEditor</code>的月下载量吊打了<code>wangEditor</code>，并且最新的<code>wangEditor5</code>月下载量不过1400，个人比较倾向于使用月下载量10000+的</p>
<h3 id="github关键数据比较："><a href="#github关键数据比较：" class="headerlink" title="github关键数据比较："></a>github关键数据比较：</h3><p><code>CKEditor</code>的<code>GitHub</code>星星数与<code>issues</code>数量如下图所示：</p>
<p><img src="ckeditor-star.png" alt="ckeditor-star.png"></p>
<p><code>wangEditor</code>的<code>GitHub</code>星星数与<code>issues</code>数量如下图所示：</p>
<p><img src="wangEditor-star.png" alt="wangEditor-star.png"></p>
<p>结论：<code>wangEditor</code>在<code>star</code>上和处理问题的及时程度秒杀了<code>CKEditor</code>, 这一定程度可能也是<code>CKEditor</code>的<code>star</code>如此少的原因，但介于<code>wangEditor</code>是由国人开发，国人开发的特点是<code>star</code>量比较虚，实际使用量和其<code>star</code>量不成正比，参考字节跳动web infra团队开源的<code>Modern.js</code></p>
<h3 id="打包体积比较"><a href="#打包体积比较" class="headerlink" title="打包体积比较"></a>打包体积比较</h3><p>相同功能的情况下<br><code>CKEditor</code>体积<br><img src="ckeditor-build.png" alt="ckeditor-build.png"></p>
<p><code>wangEditor</code>体积<br><img src="wang-editor-build.png" alt="wang-editor-build.png"></p>
<p>结论：</p>
<ol>
<li>同样的功能<code>CKEditor</code>的打包体积更小，B端要求不高，C端原则基本遵循满足需求的情况下，能使用小的就使用小的</li>
<li><code>CKEditor</code>功能栏采取按需加载的方式，即我们如果不需要某些功能，那些功能文件就不会被打包，测试了一下如果只留一个<code>Bold</code>插件的情况下可以减少_42.2kb_的js体积</li>
</ol>
<a id="more"></a>
<h3 id="功能比较"><a href="#功能比较" class="headerlink" title="功能比较"></a>功能比较</h3><p>主要功能大同小异，性能上的表现也几乎一致，<code>CKEditor</code>的亮点在于其插件化的扩展更加友好， 除了自己编写插件，还可以继承已有的插件，重写对应的插件方法，如果需要继承，官网的插件都是提供对应的方法的，重写方法就好。并且插件的编写方式类似于编写<code>webpack</code>的插件，提供了一系列的钩子在特定的条件下执行，后面会详细介绍。</p>
<h2 id="CkEditor基本环境搭建"><a href="#CkEditor基本环境搭建" class="headerlink" title="CkEditor基本环境搭建"></a>CkEditor基本环境搭建</h2><p>根据业务需要, 使用<code>create-react-app</code>搭建项目, 使用<code>react-app-rewired</code>启动项目, 使用<code>customize-cra</code>修改<code>webpack</code>配置</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add --dev \</span><br><span class="line">    css-loader@5 \</span><br><span class="line">    postcss-loader@4 \</span><br><span class="line">    raw-loader@4 \</span><br><span class="line">    style-loader@2 \</span><br><span class="line">    webpack@5 \</span><br><span class="line">    webpack-cli@4</span><br></pre></td></tr></table></figure>
<h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3><p><code>CKEditor</code>集成到项目中需要重新定义某些文件的解析规则<br>否则会报<br><code>Error: Cannot read property &#39;getAttribute&#39; of null (ckeditor)</code><br><a href="https://stackoverflow.com/questions/66416928/error-cannot-read-property-getattribute-of-null-ckeditor" target="_blank" rel="noopener">https://stackoverflow.com/questions/66416928/error-cannot-read-property-getattribute-of-null-ckeditor</a></p>
<p>需要做如下解析：</p>
<ol>
<li>内置的<code>svg</code>文件需要使用<code>raw-loader</code></li>
<li>如果需要做<strong>视觉集成(主题)</strong>, 内置的<code>css</code>文件优先使用<code>postcss-loader</code>,并且引入<code>@ckeditor/ckeditor5-theme-lark</code>包, 主题将增加约_30kb_的打包体积, 开发者可以酌情考虑。链接如下：<br><a href="https://ckeditor.com/docs/ckeditor5/latest/examples/framework/theme-customization.html" target="_blank" rel="noopener">https://ckeditor.com/docs/ckeditor5/latest/examples/framework/theme-customization.html</a></li>
<li>对于特定的<code>CKEditor</code>中的<code>css</code>样式，可以用如下的正则表达式判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> CKERegex = &#123;</span><br><span class="line">    svg: <span class="regexp">/ckeditor5-[^/\\]+[/\\]theme[/\\]icons[/\\][^/\\]+\.svg$/</span>,</span><br><span class="line">    css: <span class="regexp">/ckeditor5-[^/\\]+[/\\]theme[/\\].+\.css/</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        postcssOptions: styles.getPostCssConfig(&#123;</span><br><span class="line">            themeImporter: &#123;</span><br><span class="line">                themePath: <span class="built_in">require</span>.resolve(<span class="string">'@ckeditor/ckeditor5-theme-lark'</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            minify: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="富文本的模式"><a href="#富文本的模式" class="headerlink" title="富文本的模式"></a>富文本的模式</h3><ol>
<li>经典模式如下</li>
</ol>
<p><code>npm install --save @ckeditor/ckeditor5-build-classic</code></p>
<p><img src="editor-classic.png" alt="editor-classic.png"></p>
<ol start="2">
<li>内联模式</li>
</ol>
<p><code>npm install --save @ckeditor/ckeditor5-build-inline</code></p>
<p><img src="editor-inline.png" alt="editor-inline.png"></p>
<ol start="3">
<li>气泡模式</li>
</ol>
<p><code>npm install --save @ckeditor/ckeditor5-build-balloon</code><br><img src="editor-balloon.png" alt="editor-balloon.png"></p>
<ol start="4">
<li>气泡块模式<br><code>npm install --save @ckeditor/ckeditor5-build-balloon-block</code></li>
</ol>
<p><img src="editor-balloon-block.png" alt="editor-balloon-block.png"></p>
<ol start="5">
<li>文档模式<br><code>npm install --save @ckeditor/ckeditor5-build-decoupled-document</code></li>
</ol>
<p><img src="editor-document.png" alt="editor-document.png"></p>
<p>文档链接如下：<br><a href="https://ckeditor.com/docs/ckeditor5/latest/installation/advanced/alternative-setups/predefined-builds.html" target="_blank" rel="noopener">https://ckeditor.com/docs/ckeditor5/latest/installation/advanced/alternative-setups/predefined-builds.html</a></p>
<h3 id="插件添加"><a href="#插件添加" class="headerlink" title="插件添加"></a>插件添加</h3><p>插件添加逻辑必须遵循官方文档<br>个人比较推荐从以下的网站进去，定义自己的模板<br><a href="https://ckeditor.com/ckeditor-5/online-builder/" target="_blank" rel="noopener">https://ckeditor.com/ckeditor-5/online-builder/</a></p>
<p>按照指示下载完成后会有以下的文件，还有demo，如下图<br><img src="online-builder.png" alt="online-builder.png"></p>
<p>也可以根据已有的插件集，像上图那样的自己去引用官方已有的插件, 对应的所有插件如下：<br><a href="https://ckeditor.com/docs/ckeditor5/latest/features/index.html" target="_blank" rel="noopener">https://ckeditor.com/docs/ckeditor5/latest/features/index.html</a></p>
<h3 id="编写CkEditor组件"><a href="#编写CkEditor组件" class="headerlink" title="编写CkEditor组件"></a>编写CkEditor组件</h3><p>当前组件被<code>antd</code>的<code>Form</code>包裹，作为表单组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CKEditor</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; onChange, readOnly, value, onError &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = useCallback(<span class="function">(<span class="params">event, editor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = editor.getData();</span><br><span class="line">    onChange(data)</span><br><span class="line">  &#125;, [onChange])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleBlur = useCallback(<span class="function">(<span class="params">event, editor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = editor.getData();</span><br><span class="line">    onChange(data)</span><br><span class="line">  &#125;, [onChange])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;CKEditorContext context=&#123;Context&#125;&gt;</span><br><span class="line">      &lt;CKEditor</span><br><span class="line">        editor=&#123;ClassicEditor&#125;</span><br><span class="line">        config=&#123;&#123;</span><br><span class="line">          <span class="comment">// 这里可以自定义配置项</span></span><br><span class="line">          removePlugins: [<span class="string">'link'</span>, <span class="string">'insertTable'</span>, <span class="string">'mediaEmbed'</span>],</span><br><span class="line">          toolbar: [<span class="string">'bold'</span>, <span class="string">'italic'</span>, <span class="string">'bulletedList'</span>, <span class="string">'numberedList'</span>, <span class="string">'imageUpload'</span>],</span><br><span class="line">          <span class="comment">// toolbar: ['bold', 'italic']</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">        disabled=&#123;readOnly&#125;</span><br><span class="line">        data=&#123;value || <span class="string">'&lt;p /&gt;'</span>&#125;</span><br><span class="line">        onReady=&#123;editor =&gt; &#123;</span><br><span class="line">          <span class="comment">// You can store the "editor" and use when it is needed.</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Editor1 is ready to use!'</span>, editor);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        <span class="comment">// 相当于 editor.model.document.on("change:data", handleChange)</span></span><br><span class="line">        onChange=&#123;handleChange&#125;</span><br><span class="line">        onBlur=&#123;handleBlur&#125;</span><br><span class="line">        onError=&#123;onError || <span class="built_in">console</span>.error&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/CKEditorContext&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default CKEditor;</span></span><br></pre></td></tr></table></figure>

<p>关键属性如下：</p>
<ul>
<li><code>editor</code>：使用的富文本编辑器模板</li>
<li><code>config</code>：富文本编辑器的配置项，默认会用<code>Editor.defaultConfig</code>配置好的</li>
<li><code>disabled</code>: 富文本是否可编辑</li>
<li><code>data</code>: 富文本的<code>html</code>字符串</li>
<li><code>onReady</code>: 编辑器刚构建好时会调用，官网推荐在这里将富文本做存储，避免重复构建</li>
<li><code>onChange</code>: 改变时调用</li>
<li><code>onBlur</code>: 焦点变化时调用</li>
<li><code>onError</code>: 出现错误时调用<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4></li>
</ul>
<ol>
<li>编辑器被重复引用：</li>
</ol>
<ul>
<li>产生原因： <ul>
<li><code>config</code>属性中有<code>plugins</code>属性，官网将对应的插件直接在组件引用</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Essentials <span class="keyword">from</span> <span class="string">'@ckeditor/ckeditor5-essentials/src/essentials'</span>;</span><br><span class="line"><span class="keyword">import</span> Bold <span class="keyword">from</span> <span class="string">'@ckeditor/ckeditor5-basic-styles/src/bold'</span>;</span><br><span class="line"><span class="keyword">import</span> Italic <span class="keyword">from</span> <span class="string">'@ckeditor/ckeditor5-basic-styles/src/italic'</span>;</span><br><span class="line"><span class="keyword">import</span> Paragraph <span class="keyword">from</span> <span class="string">'@ckeditor/ckeditor5-paragraph/src/paragraph'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> editorConfiguration = &#123;</span><br><span class="line">    plugins: [ Essentials, Bold, Italic, Paragraph ],</span><br><span class="line">    toolbar: [ <span class="string">'bold'</span>, <span class="string">'italic'</span> ]</span><br><span class="line">&#125;;</span><br><span class="line">    &lt;CKEditor</span><br><span class="line">    editor=&#123; ClassicEditor &#125;</span><br><span class="line">    config=&#123; editorConfiguration &#125;</span><br><span class="line">    ...其他属性</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>问题链接:<a href="https://github.com/ckeditor/ckeditor5/issues/5776" target="_blank" rel="noopener">https://github.com/ckeditor/ckeditor5/issues/5776</a> </li>
<li>解决方案：编写前文图例的<code>ckeditor.js</code>，然后将<code>CkEditor组件</code>需要的配置注入，实际编写的组件中引入对应<code>js</code>的文件，不需要的删除，目前没看到什么场景必须使用<code>config.plugins</code> </li>
</ul>
<ol start="2">
<li>打包内存溢出(我没遇到过)<br>解决方案官网已经给出，链接如下：<br><a href="https://ckeditor.com/docs/ckeditor5/latest/installation/getting-started/frameworks/react.html#integrating-a-build-from-the-online-builder" target="_blank" rel="noopener">https://ckeditor.com/docs/ckeditor5/latest/installation/getting-started/frameworks/react.html#integrating-a-build-from-the-online-builder</a></li>
</ol>
<h3 id="中文包"><a href="#中文包" class="headerlink" title="中文包"></a>中文包</h3><p>全局引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@ckeditor/ckeditor5-build-classic/build/translations/zh-cn"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Editor.defaultConfig.language = <span class="string">'zh-cn'</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><h4 id="npm包的形式"><a href="#npm包的形式" class="headerlink" title="npm包的形式"></a>npm包的形式</h4><p>个人推荐使用<a href="https://www.npmjs.com/package/ckeditor5-package-generator" target="_blank" rel="noopener">ckeditor5-package-generator</a></p>
<ol>
<li><code>CkEditor5</code>要求所有的插件包都必须以<code>ckeditor5-</code>开头，中间字符为<code>0-9</code>、<code>a-z</code>、<code>. - _</code>，创建和打包的时候都会正则校验 </li>
<li>上述插件会提供一个打包模板，我们可以在这个模板上扩展，会有一个已经编写好的插件 </li>
</ol>
<p>详细的编写方式可见<a href="https://ckeditor.com/docs/ckeditor5/latest/framework/guides/plugins/creating-simple-plugin.html" target="_blank" rel="noopener">参考链接</a></p>
<p>简述如下：</p>
<ol>
<li>一个插件就是一个继承于<code>Plugin</code>的<code>class</code></li>
<li><code>editor.ui.componentFactory</code>负责添加一个工具，可以使用模型层的监听器为用户对工具栏上自定义ui定义其操作</li>
</ol>
<p>注意点：<br>如果多个插件打包，并非工具生成的目录， 目录如下<br>可以直接打包，也可以使用<code>dll模式</code>，这里推荐直接打包，<code>webpack5</code>自带缓存，<code>dll</code>不会对打包速度有明显的效果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">|- src</span><br><span class="line">  |- ckeditor5-plugin1</span><br><span class="line">    |- lang</span><br><span class="line">      |- translations</span><br><span class="line">        |- zh-cn.po</span><br><span class="line">      |- contexts.json</span><br><span class="line">    |- src</span><br><span class="line">      |- index.js</span><br><span class="line">  |- ckeditor5-plugin2</span><br><span class="line">    |- lang</span><br><span class="line">      |- translations</span><br><span class="line">        |- zh-cn.po</span><br><span class="line">      |- contexts.json</span><br><span class="line">    |- src</span><br><span class="line">      |- index.js</span><br><span class="line">  |- ckeditor5-plugin3</span><br><span class="line">    |- lang</span><br><span class="line">      |- translations</span><br><span class="line">        |- zh-cn.po</span><br><span class="line">      |- contexts.json</span><br><span class="line">    |- src</span><br><span class="line">      |- index.js</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Plugin <span class="keyword">from</span> <span class="string">'@ckeditor/ckeditor5-core/src/plugin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertImage</span> <span class="keyword">extends</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="keyword">const</span> editor = <span class="keyword">this</span>.editor;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 为工具栏添加一个 insertImage，使用 imageIcon</span></span><br><span class="line">        editor.ui.componentFactory.add( <span class="string">'insertImage'</span>, locale =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> view = <span class="keyword">new</span> ButtonView( locale );</span><br><span class="line">            view.set( &#123;</span><br><span class="line">                label: <span class="string">'Insert image'</span>,</span><br><span class="line">                icon: imageIcon,</span><br><span class="line">                tooltip: <span class="literal">true</span></span><br><span class="line">            &#125; );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听执行这个Button，会弹出输入url，监听模型层，根据输入的url展示对应的图片，并插入到模型层对应的鼠标 selection 节点上</span></span><br><span class="line">            view.on( <span class="string">'execute'</span>, () =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> imageUrl = prompt( <span class="string">'Image URL'</span> );</span><br><span class="line"></span><br><span class="line">                editor.model.change( <span class="function"><span class="params">writer</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> imageElement = writer.createElement( <span class="string">'imageBlock'</span>, &#123;</span><br><span class="line">                        src: imageUrl</span><br><span class="line">                    &#125; );</span><br><span class="line"></span><br><span class="line">                    editor.model.insertContent( imageElement, editor.model.document.selection );</span><br><span class="line">                &#125; );</span><br><span class="line">            &#125; );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h3><p><a href="https://ckeditor.com/docs/ckeditor5/latest/framework/guides/deep-dive/upload-adapter.html" target="_blank" rel="noopener">完整文档可见</a><br><code>CKEditor</code>提供了自定义扩展，根据先有的<code>adapter</code>做扩展，以下都将用<code>Image Uploader</code>做举例</p>
<p>例如： <code>Upload adapter</code>作用是在文件编辑器和文件上传服务器之间构建一个桥梁，我们可以自定义扩展用户上传的行为以及上传到服务器的接口等，这个<code>adapter</code>是基于<code>File repository plugin</code>创建的，像<code>image upload plugin</code>也是基于这个创建的，``File repository plugin`是整个上传的核心插件。</p>
<p>区别：<br>自定义插件是完全从ui到功能的自定义实现<br>自定义扩展是基于已有的富文本编辑器功能，做一些替换或者功能的提升</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>首先，图像（或图像）需要进入富文本编辑器内容。有很多方法可以做到这一点，例如：</li>
</ol>
<ul>
<li>从剪贴板粘贴图像</li>
<li>从文件系统中拖动文件</li>
<li>通过文件系统对话框选择图像，即选择上传</li>
</ul>
<p>这些行为都将被<code>image uploader plugin</code>插件捕获</p>
<ol start="2">
<li><p>对于每个上传的图像都会被<code>image upload plugin</code>创建出<code>file loader</code>的实例，通过<code>upload adapter</code>将其上传到服务器，并根据url正确的展示在编辑器内 </p>
</li>
<li><p>在上传图片时，<code>image upload plugin</code>会做以下事情 </p>
</li>
</ol>
<ul>
<li>创建图像的占位符</li>
<li>插入到编辑器</li>
<li>展示每一个图像的进度条</li>
<li>上传完成前如果做了删除图片的操作，终止上传</li>
</ul>
<ol start="4">
<li>图片上传完成，<code>upload adapter</code>通知<code>editor</code>（调用<code>Promise</code>），<code>image upload</code>创建的标签中的<code>src</code>和<code>srcset</code>将被替换</li>
</ol>
<h4 id="扩展方式"><a href="#扩展方式" class="headerlink" title="扩展方式"></a>扩展方式</h4><ol>
<li><p><code>image upload</code>必须在编辑器中启用。它在所有官方版本中默认启用，如果正在自定义<code>CKEditor 5</code>编辑器，那么需要自己写这个插件</p>
</li>
<li><p>需要自定义<code>upload adapter</code>，我们可以根据使用已有的<code>upload adapter</code>，也可以自定义（建议自定义，将上传和回显操作控制在自己手中）</p>
<h4 id="编写UploadAdapter"><a href="#编写UploadAdapter" class="headerlink" title="编写UploadAdapter"></a>编写UploadAdapter</h4></li>
<li><p>自定义<code>UploadAdapter</code>，主要是自定义上传的服务器路径以及自定义回显方式 </p>
</li>
<li><p>根据<a href="https://ckeditor.com/docs/ckeditor5/latest/api/module_upload_filerepository-UploadAdapter.html" target="_blank" rel="noopener">UploadAdapter参考链接</a>`可以找到对应的方法 </p>
</li>
</ol>
<ul>
<li><code>upload()</code>返回一个<code>Promise</code> </li>
<li><code>abort()</code>上传中止所做的操作 </li>
</ul>
<ol start="3">
<li>通常我们使用<code>XMLHttpRequest</code>在这个<code>UploadAdapter</code>中，详细请见<a href="https://ckeditor.com/docs/ckeditor5/latest/framework/guides/deep-dive/upload-adapter.html#implementing-a-custom-upload-adapter" target="_blank" rel="noopener">创建一个简易的UploadAdapter</a>，完整代码如下</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUploadAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(loader) &#123;</span><br><span class="line">        <span class="comment">// The file loader instance to use during the upload.</span></span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Starts the upload process.</span></span><br><span class="line">    upload() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loader.file.then(</span><br><span class="line">            (file) =&gt;</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.initRequest();</span><br><span class="line">                    <span class="keyword">this</span>.initListeners(resolve, reject, file);</span><br><span class="line">                    <span class="keyword">this</span>.sendRequest(file);</span><br><span class="line">                &#125;),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aborts the upload process.</span></span><br><span class="line">    abort() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.xhr) &#123;</span><br><span class="line">            <span class="keyword">this</span>.xhr.abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializes the XMLHttpRequest object using the URL passed to the constructor.</span></span><br><span class="line">    initRequest() &#123;</span><br><span class="line">        <span class="keyword">this</span>.xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="comment">// Note that your request may look different. It is up to you and your editor</span></span><br><span class="line">        <span class="comment">// integration to choose the right communication channel. This example uses</span></span><br><span class="line">        <span class="comment">// a POST request with JSON as a data structure but your configuration</span></span><br><span class="line">        <span class="comment">// could be different.</span></span><br><span class="line">        <span class="keyword">this</span>.xhr.open(<span class="string">'POST'</span>, <span class="string">'/api/img/upload'</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.xhr.responseType = <span class="string">'json'</span>;</span><br><span class="line">        <span class="comment">// 设置请求头（权限控制）</span></span><br><span class="line">        <span class="keyword">this</span>.xhr.setRequestHeader(<span class="string">'AUTHENTICATION'</span>, <span class="string">'111'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializes XMLHttpRequest listeners.</span></span><br><span class="line">    initListeners(resolve, reject, file) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; xhr, loader &#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> genericErrorText = <span class="string">`Couldn't upload file: <span class="subst">$&#123;file.name&#125;</span>.`</span>;</span><br><span class="line">        xhr.addEventListener(<span class="string">'error'</span>, () =&gt; reject(genericErrorText));</span><br><span class="line">        xhr.addEventListener(<span class="string">'abort'</span>, () =&gt; reject());</span><br><span class="line">        xhr.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; response &#125; = xhr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This example assumes the XHR server's "response" object will come with</span></span><br><span class="line">            <span class="comment">// an "error" which has its own "message" that can be passed to reject()</span></span><br><span class="line">            <span class="comment">// in the upload promise.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Your integration may handle upload errors in a different way so make sure</span></span><br><span class="line">            <span class="comment">// it is done properly. The reject() function must be called when the upload fails.</span></span><br><span class="line">            <span class="keyword">if</span> (!response || response.error) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(</span><br><span class="line">                    response &amp;&amp; response.error ? response.error.message : genericErrorText,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the upload is successful, resolve the upload promise with an object containing</span></span><br><span class="line">            <span class="comment">// at least the "default" URL, pointing to the image on the server.</span></span><br><span class="line">            <span class="comment">// This URL will be used to display the image in the content. Learn more in the</span></span><br><span class="line">            <span class="comment">// UploadAdapter#upload documentation.</span></span><br><span class="line">            <span class="keyword">return</span> resolve(&#123;</span><br><span class="line">                <span class="keyword">default</span>: response.data,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload progress when it is supported. The file loader has the #uploadTotal and #uploaded</span></span><br><span class="line">        <span class="comment">// properties which are used e.g. to display the upload progress bar in the editor</span></span><br><span class="line">        <span class="comment">// user interface.</span></span><br><span class="line">        <span class="keyword">if</span> (xhr.upload) &#123;</span><br><span class="line">            xhr.upload.addEventListener(<span class="string">'progress'</span>, (evt) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (evt.lengthComputable) &#123;</span><br><span class="line">                    loader.uploadTotal = evt.total;</span><br><span class="line">                    loader.uploaded = evt.loaded;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepares the data and sends the request.</span></span><br><span class="line">    sendRequest(file) &#123;</span><br><span class="line">        <span class="comment">// Prepare the form data.</span></span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line">        data.append(<span class="string">'attach'</span>, file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Important note: This is the right place to implement security mechanisms</span></span><br><span class="line">        <span class="comment">// like authentication and CSRF protection. For instance, you can use</span></span><br><span class="line">        <span class="comment">// XMLHttpRequest.setRequestHeader() to set the request headers containing</span></span><br><span class="line">        <span class="comment">// the CSRF token generated earlier by your application.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send the request.</span></span><br><span class="line">        <span class="keyword">this</span>.xhr.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyUploadAdapter;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CKEditor</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer(持续更新)</title>
    <url>/2022/06/09/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h1 id="Day1——栈与队列（简单）"><a href="#Day1——栈与队列（简单）" class="headerlink" title="Day1——栈与队列（简单）"></a>Day1——栈与队列（简单）</h1><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line"></span><br><span class="line">&gt;[[],[],[5],[2],[],[]]</span><br></pre></td></tr></table></figure>
<p>输出: [null,-1,null,null,5,2]<br/></p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>解题关键：了解栈和队列的区别，两个栈模拟，一个栈用于进，一个栈用于出</p>
<p>栈和队列的区别：</p>
<p>栈：先进后出(只能一端插入和删除)</p>
<p>队列：先进先出(只能一端插入，另一端删除)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CQueue = <span class="function"><span class="keyword">function</span>(<span class="params">quene = []</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.instack = []</span><br><span class="line">   <span class="keyword">this</span>.outstack = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.appendTail = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.instack.push(value)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.deleteHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 删除的时候先用另一个栈来模拟队列的另一端</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.outstack.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.instack.length)&#123; <span class="comment">// 没有元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.instack.length)&#123;</span><br><span class="line">                <span class="keyword">this</span>.outstack.push(<span class="keyword">this</span>.instack.pop())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.outstack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<hr>
<h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line"></span><br><span class="line">&gt;[],[-2],[0],[-3],[],[],[],[]]</span><br></pre></td></tr></table></figure>
<p>输出: [null,null,null,null,-3,null,0,-2]<br/><br><br/><br>解释: MinStack minStack = new MinStack();<br/><br>minStack.push(-2);<br/><br>minStack.push(0);<br/><br>minStack.push(-3);<br/><br>minStack.getMin(); –&gt; 返回 -3.<br/><br>minStack.pop(); minStack.top(); –&gt; 返回 0.<br/><br>minStack.getMin(); –&gt; 返回 -2.<br/></p>
</blockquote>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>解题关键：创建辅助栈<code>minStack</code>, 与栈空间保持同步操作, 空间换时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inStack = []</span><br><span class="line">    <span class="keyword">this</span>.minStack = [<span class="literal">Infinity</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inStack.push(x)</span><br><span class="line">    <span class="keyword">this</span>.minStack.push(<span class="built_in">Math</span>.min(<span class="keyword">this</span>.minStack[<span class="keyword">this</span>.minStack.length - <span class="number">1</span>], x))</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inStack.pop()</span><br><span class="line">    <span class="keyword">this</span>.minStack.pop()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.inStack[<span class="keyword">this</span>.inStack.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.minStack[<span class="keyword">this</span>.minStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.min()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="Day2——链表（简单）"><a href="#Day2——链表（简单）" class="headerlink" title="Day2——链表（简单）"></a>Day2——链表（简单）</h1><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;head &#x3D; [1,3,2]</span><br></pre></td></tr></table></figure>
<p>输出: [2,3,1]<br/></p>
</blockquote>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>方法：定义一个数组，一边遍历一边往数组前面添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePrint = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number = [];</span><br><span class="line">    <span class="keyword">let</span> node = head</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        number.unshift(node.val)</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br/></p>
</blockquote>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>方法：定义两个指针，一前一后，一边遍历一边翻转<br>注意点：注意后指针指向前指针时需要一个暂存指针指向下一次循环的指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> cur = head</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = cur.next</span><br><span class="line">        cur.next = prev</span><br><span class="line">        prev = cur </span><br><span class="line">        cur = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h2><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><img src="copyList.png" alt=""><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<p>输出:[[7,null],[13,0],[11,4],[10,2],[1,0]]<br/></p>
</blockquote>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>陷阱：复制的时候未必所有的节点都生成了新的，要避免指到旧的</p>
<p>方法：</p>
<ol>
<li>hash表，第一次遍历存好最新的，遍历hash表设置random</li>
<li>遍历旧链表，复制一份到每个节点的后面(不赋值random)，新节点的next指向原来旧节点的下一个节点，这样可以减少空间(空间复杂度O(1))</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // Definition for a Node.</span></span><br><span class="line"><span class="comment"> * function Node(val, next, random) &#123;</span></span><br><span class="line"><span class="comment"> *    this.val = val;</span></span><br><span class="line"><span class="comment"> *    this.next = next;</span></span><br><span class="line"><span class="comment"> *    this.random = random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一: hash表</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        map.set(node, <span class="keyword">new</span> Node(node.val))</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        map.get(node).next = node.next ? map.get(node.next) : <span class="literal">null</span></span><br><span class="line">        map.get(node).random = node.random ? map.get(node.random) : <span class="literal">null</span></span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：后继节点</span></span><br><span class="line"><span class="keyword">var</span> copyRandomList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> node = head;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">let</span> nodeNew = <span class="keyword">new</span> Node(node.val, node.next)</span><br><span class="line">        node.next = nodeNew</span><br><span class="line">        node = nodeNew.next</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">let</span> nodeNew = node.next;</span><br><span class="line">        nodeNew.random = node.random ? node.random.next ： <span class="literal">null</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">const</span> returnNode = node.next</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        nodeNew.next = nodeNew.next ？ nodeNew.next.next : <span class="literal">null</span></span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day3——字符串（简单）"><a href="#Day3——字符串（简单）" class="headerlink" title="Day3——字符串（简单）"></a>Day3——字符串（简单）</h1><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;s &#x3D; &quot;We are happy.&quot;</span><br></pre></td></tr></table></figure>
<p>输出:”We%20are%20happy.”<br/></p>
</blockquote>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>直接调用现成方法即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replaceAll(<span class="string">' '</span>, <span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br></pre></td></tr></table></figure>
<p>输出: “cdefgab”<br/></p>
</blockquote>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>方法一： 运用取余的特性去解 <strong>(遍历到的第i项 + 第n位开始翻转) / 字符串长度</strong> 就是对应位置</p>
<p>方法二： 直接切割成俩数组, 倒转拼接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(s).map(<span class="function">(<span class="params">_v,i</span>)=&gt;</span>s[((i+n))%s.length]).join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> left = s.slice(<span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">const</span> right = s.slice(n, s.length)</span><br><span class="line">    <span class="keyword">return</span> right + left</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Day4——查找算法（简单）"><a href="#Day4——查找算法（简单）" class="headerlink" title="Day4——查找算法（简单）"></a>Day4——查找算法（简单）</h1><p>Day4实在太简单了，稍微挑一个有技巧一点的</p>
<h2 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h2><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[0,1,3]</span><br></pre></td></tr></table></figure>
<p>输出:2<br/></p>
</blockquote>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>二分查找法</p>
<ol>
<li><p>左指针指向第一个，右指针指向最后一个，定义一个指针指向中间</p>
</li>
<li><p>如果<code>number[middle] === middle</code>, 那么右边缺, 否则左边缺</p>
</li>
<li><p>当跳出循环的时候, 左指针指向右区间第一个元素，右指针指向左区间最后一个元素, 即返回左指针</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> j = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(i + (j - i) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(number[middle] === middle)&#123;</span><br><span class="line">            i = middle + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j = middle - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Day5——查找算法（中等）"><a href="#Day5——查找算法（中等）" class="headerlink" title="Day5——查找算法（中等）"></a>Day5——查找算法（中等）</h1><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;二维数组</span><br><span class="line">&gt;[</span><br><span class="line"> [1,   4,  7, 11, 15],</span><br><span class="line"> [2,   5,  8, 12, 19],</span><br><span class="line"> [3,   6,  9, 16, 22],</span><br><span class="line"> [10, 13, 14, 17, 24],</span><br><span class="line"> [18, 21, 23, 26, 30]</span><br><span class="line">&gt;]</span><br><span class="line">&gt;target 5</span><br></pre></td></tr></table></figure>
<p>输出: true<br/></p>
</blockquote>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>技巧：从<strong>右上角</strong>开始找，如果target小，找左边一列，target大，找下一行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!matrix || !matrix.length || !matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> line = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(line &lt;= matrix.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[line][col])&#123;</span><br><span class="line">            col--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[line][col])&#123;</span><br><span class="line">            line++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h2><h3 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;s &#x3D; &quot;abaccdeff&quot;</span><br></pre></td></tr></table></figure>
<p>输出:’b’<br/></p>
</blockquote>
<h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>关键: 两次遍历，第一次用hash表存字符出现的次数，第二次如果次数为1直接返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> time = map.get(s[i]) || <span class="number">0</span></span><br><span class="line">        map.set(s[i], time + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(s[i]) === <span class="number">1</span>) <span class="keyword">return</span> s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day6——搜索与回溯算法（简单）"><a href="#Day6——搜索与回溯算法（简单）" class="headerlink" title="Day6——搜索与回溯算法（简单）"></a>Day6——搜索与回溯算法（简单）</h1><p>三个题目长得一样的，挑一个讲</p>
<h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><p>之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印</p>
<h3 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>
<p>输出:[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br/></p>
</blockquote>
<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>关键点：</p>
<ol>
<li>广度优先(需要一个队列)</li>
<li>一正一反，push结果的时候根据是否需要倒序输出决定用push还是unshift</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">var</span> quene = [[root]];</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> isLeft = <span class="number">1</span>; <span class="comment">// 奇数表示正序，偶数表示倒序</span></span><br><span class="line">    <span class="keyword">while</span>(quene.length)&#123;</span><br><span class="line">        <span class="keyword">const</span> level = quene.shift();</span><br><span class="line">        <span class="keyword">const</span> levelRes = [];</span><br><span class="line">        <span class="keyword">const</span> levelQuene = [];</span><br><span class="line">        level.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(item.left) &#123;</span><br><span class="line">                levelQuene.push(item.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(item.right) &#123;</span><br><span class="line">                levelQuene.push(item.right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isLeft % <span class="number">2</span>)&#123;</span><br><span class="line">                levelRes.push(item.val)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                levelRes.unshift(item.val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        isLeft++</span><br><span class="line">        <span class="keyword">if</span>(levelQuene.length)&#123;</span><br><span class="line">            quene.push(levelQuene)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(levelRes.length)&#123;</span><br><span class="line">            res.push(levelRes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day7——搜索与回溯算法二（简单）"><a href="#Day7——搜索与回溯算法二（简单）" class="headerlink" title="Day7——搜索与回溯算法二（简单）"></a>Day7——搜索与回溯算法二（简单）</h1><h2 id="剑指-Offer-26-树的子结构-判断子树"><a href="#剑指-Offer-26-树的子结构-判断子树" class="headerlink" title="剑指 Offer 26. 树的子结构(判断子树)"></a>剑指 Offer 26. 树的子结构(判断子树)</h2><h3 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h3><p>例如:<br>给定的树 A:</p>
<pre><code> 3

/ \</code></pre><p>   4   5</p>
<p>  / \</p>
<p> 1   2</p>
<p>给定的树 B：</p>
<p>   4 </p>
<p>  /</p>
<p> 1</p>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br></pre></td></tr></table></figure>
<p>输出:false<br/></p>
</blockquote>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p>解题关键：</p>
<ol>
<li><p>深度遍历父树，遇到val相同的，就有可能是子树，依次比较父树和子树的每个节点</p>
</li>
<li><p>递归判断相等时，如果B没有了，说明已经匹配完成了，为true。如果A没有了，说明越过A树，为false，如果val值不一样，那么匹配失败，false。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSubStructure = <span class="function"><span class="keyword">function</span>(<span class="params">A, B</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameTree</span>(<span class="params">A, B</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!B)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!A)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A.val !== B.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(A.left, B) &amp;&amp; isSameTree(A.right, B)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><h3 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;root &#x3D; [4,2,7,1,3,6,9]</span><br></pre></td></tr></table></figure>
<p>输出: [4,7,2,9,6,3,1]<br/></p>
</blockquote>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>解题思路：</p>
<ol>
<li>交换left和right，递归交换</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        mirrorTree(root.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        mirrorTree(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><h3 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h3><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><br/><br>    1</p>
<p>   / \</p>
<p>  2   2</p>
<p> / \ / \</p>
<p>3  4 4  3</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;root &#x3D; [1,2,2,3,4,4,3]</span><br></pre></td></tr></table></figure>
<p>输出: true<br/></p>
</blockquote>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p>解题思路：</p>
<p>用两个指针，一根往左走，另一根就往右走。一根往右走，另一根就往左走。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMirror</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p &amp;&amp; !q)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || !q)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.val === q.val &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day8——动态规划（简单）"><a href="#Day8——动态规划（简单）" class="headerlink" title="Day8——动态规划（简单）"></a>Day8——动态规划（简单）</h1><h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h2><h3 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;n &#x3D; 2</span><br></pre></td></tr></table></figure>
<p>输出:1<br/></p>
</blockquote>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>不要用递归（暴掉的概率太大了）</p>
<p>提供两种解法</p>
<ol>
<li>滚动数组解法</li>
</ol>
<p><img src="%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84.gif" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> mod = <span class="number">1000000007</span>; <span class="comment">// 防止过大</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">        r =(p + q) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>矩阵快速幂</p>
<p> 2.1 <a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速幂</a> <strong>O(logn)</strong> 的复杂度</p>
<ul>
<li><p>a^n = a^(2^log2(n)), 因此计算<code>O(logn)</code>的复杂度次数即可得到高次幂的结果</p>
</li>
<li><p>任意正整数的偶数n次幂，等于其<code>(n/2)^2</code>，基数则是<code>n &gt;&gt; 2</code>后的<code>(n/2)^2 * (该数)</code></p>
<p>2.2 矩阵的目的是得到递推关系<br><img src="%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E5%86%B3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt=""></p>
<p>得出我们的目的是求出矩阵的n次幂再乘以初始值</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="keyword">var</span> mutiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)&#123;</span><br><span class="line">            c[i][j] = (BigInt(a[i][<span class="number">0</span>]) * BigInt(b[<span class="number">0</span>][j])) + (BigInt(a[i][<span class="number">1</span>]) * BigInt(b[<span class="number">1</span>][j]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速幂算法，固定格式可以说</span></span><br><span class="line"><span class="keyword">var</span> pow = <span class="function">(<span class="params">a, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) === <span class="number">1</span>)&#123; <span class="comment">// 奇数</span></span><br><span class="line">            ret = mutiply(ret, a)</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt; <span class="number">1</span></span><br><span class="line">        a = mutiply(a, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mod = <span class="number">1000000007</span>; <span class="comment">// 防止过大</span></span><br><span class="line">    <span class="keyword">const</span> m = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">const</span> res = pow(m, n - <span class="number">1</span>) <span class="comment">// 需要得出来的是[F(n), F(n - 1)]，因此F(n) = res[0][0] * F(1) + res[0][0] * F(0)</span></span><br><span class="line">    <span class="keyword">return</span> BigInt(res[<span class="number">0</span>][<span class="number">0</span>]) % BigInt(mod)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h2><h3 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h3><h2 id="一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个-n-级的台阶总共有多少种跳法。"><a href="#一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个-n-级的台阶总共有多少种跳法。" class="headerlink" title="一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。"></a>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</h2><blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;n &#x3D; 2</span><br></pre></td></tr></table></figure>
<p>输出:2<br/></p>
</blockquote>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>和上面的斐波那契数列一毛一样，唯一的区别就是<strong>F(0)和F(1)的初始值不一样</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略矩阵计算方法和快速幂算法</span></span><br><span class="line"><span class="keyword">var</span> numWays = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> m = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">const</span> res = pow(m, n - <span class="number">1</span>); <span class="comment">// 需要得出来的是[F(n), F(n - 1)]，因此F(n) = res[0][0] * F(1) + res[0][0] * F(0)</span></span><br><span class="line">    <span class="keyword">const</span> ways = (res[<span class="number">0</span>][<span class="number">0</span>] * <span class="number">1</span> + res[<span class="number">0</span>][<span class="number">0</span>] * <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h2><h3 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[7,1,5,3,6,4]</span><br></pre></td></tr></table></figure>
<p>输出: 5<br/></p>
</blockquote>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>方法：</p>
<p>遍历每一天，每一天都在幻想买的是最低点，卖的是最高点即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!prices.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> minPrice = price[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> maxEarn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minPrice)&#123;</span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] - minPrice &gt; maxEarn)&#123;</span><br><span class="line">            maxEarn = prices[i] - minPrice</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxEarn &gt; <span class="number">0</span> ? maxEarn : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day9——动态规划（中等）"><a href="#Day9——动态规划（中等）" class="headerlink" title="Day9——动态规划（中等）"></a>Day9——动态规划（中等）</h1><h2 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h2><h3 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br></pre></td></tr></table></figure>
<p>输出:6<br/><br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>提供两种解法，均比较重要</p>
<ol>
<li><p>动态规划, 滚动数组</p>
<ul>
<li><code>Max{F(n - 1) + nums[i], nums[i]}</code></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> q = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 看q是取之前的和还是说取本次这个数</span></span><br><span class="line">        q = <span class="built_in">Math</span>.max(q + nums[i], nums[i]);</span><br><span class="line">        <span class="comment">// 重新设置max</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(q, nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>分治算法</strong></li>
</ol>
<p>分治算法就是将一个复杂的问题分成几个相似或者相同的小问题，再将小问题合并。</p>
<p>本题思路：</p>
<p>分成多段，分别找出其中连续子数组中的最大和</p>
<ul>
<li><p>如果只有1个元素，那么最大和就是那个元素</p>
</li>
<li><p>如果有多个元素，那么递归拆分</p>
</li>
<li><p>合并求最大和时，加入分治了两个数组a、b, 针对两个数组合并</p>
<ul>
<li>分别拿两个数组每个元素的和得出一个iSum(跨数组)</li>
<li>分别拿两个数组的头作为起点算个最大和<code>lSum = Max{a.lSum, b.lSum + a.iSum}</code></li>
<li>分别拿两个数组的尾巴作为终点算个最大和<code>rSum = Max{b.rSum, a.rSum + b.iSum}</code> <strong>比较的都是不跨数组和跨数组的情况</strong></li>
<li>两个数组的最大和为 <code>mSum = Max{a.mSum, b.mSum, a.rSum + b.lSum}</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">l, r, m, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lSum = l</span><br><span class="line">    <span class="keyword">this</span>.rSum = r</span><br><span class="line">    <span class="keyword">this</span>.mSum = m</span><br><span class="line">    <span class="keyword">this</span>.iSum = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeArr</span>(<span class="params">aStatus, bStatus</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> l = <span class="built_in">Math</span>.max(aStatus.lSum, bStatus.lSum + aStatus.iSum)</span><br><span class="line">    <span class="keyword">const</span> r = <span class="built_in">Math</span>.max(aStatus.rSum + bStatus.iSum, bStatus.rSum)</span><br><span class="line">    <span class="keyword">const</span> m = <span class="built_in">Math</span>.max(aStatus.mSum, bStatus.mSum, aStatus.rSum + bStatus.lSum)</span><br><span class="line">    <span class="keyword">const</span> i = aStatus.iSum + bStatus.iSum</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(l, r, m, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">arr, start, end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start === end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Status(arr[start], arr[start], arr[start], arr[start])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middle = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> lStatus = getInfo(arr, start, middle)</span><br><span class="line">    <span class="keyword">const</span> rStatus = getInfo(arr, middle + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> mergeArr(lStatus, rStatus)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInfo(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>).mSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a>剑指 Offer 47. 礼物的最大价值</h2><h3 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;[</span><br><span class="line"> [1,3,1],</span><br><span class="line"> [1,5,1],</span><br><span class="line"> [4,2,1]</span><br><span class="line">&gt;]</span><br></pre></td></tr></table></figure>
<p>输出: 12<br/><br>解释：路径 1→3→5→2→1 可以拿到最多价值的礼物</p>
</blockquote>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>动态规划题，设置dp数组，这个数组存着走到那一步能获取到的最大价值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxValue = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> line = grid.length;</span><br><span class="line">    <span class="keyword">var</span> column = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(line).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(column).fill(<span class="number">0</span>))</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">// 这个初始值必须设置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; line;i++)&#123; <span class="comment">// 初始化每一列</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; column;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; line;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>;j &lt; column;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[line - <span class="number">1</span>][column - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day10——动态规划二（中等）"><a href="#Day10——动态规划二（中等）" class="headerlink" title="Day10——动态规划二（中等）"></a>Day10——动态规划二（中等）</h1><h2 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a>剑指 Offer 46. 把数字翻译成字符串</h2><h3 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;12258</span><br></pre></td></tr></table></figure>
<p>输出:5<br/><br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
</blockquote>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>动态规划，滚动数组，条件判断(类似青蛙跳台阶)</p>
<ol>
<li><code>F(n) = F(n - 1)</code> (如果最后两个数无法构成一个字母)</li>
<li><code>F(n) = F(n - 1) + F(n - 2)</code> (如果最后两个数可以构成一个字母)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> translateNum = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stringNum = <span class="built_in">String</span>(num)</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">1</span>, ways = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; stringNum.length;i++)&#123;</span><br><span class="line">        p = q;</span><br><span class="line">        q = ways;</span><br><span class="line">        ways = <span class="number">0</span>;</span><br><span class="line">        ways += q;</span><br><span class="line">        <span class="keyword">let</span> lastSecondNum = stringNum[i - <span class="number">1</span>] + stringNum[i]</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Number</span>(lastSecondNum) &gt;= <span class="number">10</span> || (<span class="built_in">Number</span>(lastSecondNum) &lt;= <span class="number">25</span>)&#123;</span><br><span class="line">            ways += p</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><h3 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&quot;abcabcbb&quot;</span><br></pre></td></tr></table></figure>
<p>输出: 3<br/><br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><ol>
<li>滑动窗口(双指针) + 哈希表</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">-1</span>, res = <span class="number">0</span>, hashMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashMap.has(s[i]))&#123; <span class="comment">// 如果存在</span></span><br><span class="line">            <span class="keyword">const</span> index = hashMap.get(s[i])</span><br><span class="line">            left = <span class="built_in">Math</span>.max(index, left)</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap.set(s[i], i)</span><br><span class="line">        res = <span class="built_in">Math</span>.max(res, i - left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day11——双指针（简单）"><a href="#Day11——双指针（简单）" class="headerlink" title="Day11——双指针（简单）"></a>Day11——双指针（简单）</h1><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><h3 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;head &#x3D; [4,5,1,9], val &#x3D; 5</span><br></pre></td></tr></table></figure>
<p>输出: [4,1,9]<br/><br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>建一个空的头结点，定义两个指针，一个先走一步，一个后走</p>
<ul>
<li>注意点：<code>head</code>也要指向空节点，因为头结点也有可能被删除</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> empty = <span class="keyword">new</span> ListNode()</span><br><span class="line">    empty.next = head;</span><br><span class="line">    <span class="keyword">let</span> prev = empty;</span><br><span class="line">    <span class="keyword">let</span> node = empty;</span><br><span class="line">    head = empty</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.val === val)&#123;</span><br><span class="line">            prev.next = node.next</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><h3 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br></pre></td></tr></table></figure>
<p>输出: 返回链表 4-&gt;5.<br/></p>
</blockquote>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>解题思路：双指针，前一个指针先走k步，第二根指针开始走，第一个指针走完的时候第二个指针走到第k个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> front = head;</span><br><span class="line">    <span class="keyword">var</span> back = head;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(front)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; k)&#123;</span><br><span class="line">            back = back.next</span><br><span class="line">        &#125;</span><br><span class="line">        front = front.next</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day12——双指针二（简单）"><a href="#Day12——双指针二（简单）" class="headerlink" title="Day12——双指针二（简单）"></a>Day12——双指针二（简单）</h1><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><h3 id="示例-23"><a href="#示例-23" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>
<p>输出:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br/></p>
</blockquote>
<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>一根新链表加两个指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node1 = l1;</span><br><span class="line">    <span class="keyword">let</span> node2 = l2;</span><br><span class="line">    <span class="keyword">const</span> newHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    <span class="keyword">let</span> newNode = newHead;</span><br><span class="line">    <span class="keyword">while</span>(node1 &amp;&amp; node2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2.val &lt;= node1.val)&#123;</span><br><span class="line">            newNode.next = node2</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            newNode.next = node1;</span><br><span class="line">            node1 = node1.next</span><br><span class="line">        &#125;</span><br><span class="line">        newNode = newNode.next</span><br><span class="line">    &#125;</span><br><span class="line">    newNode.next = node1 ? node1 : node2</span><br><span class="line">    <span class="keyword">return</span> newHead.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><h3 id="示例-24"><a href="#示例-24" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/><br><img src="%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9.png" alt=""><br>输出:Reference of the node with value = 8<br/><br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
</blockquote>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p>双指针，一根走完了指向另一根的头部, 相交说明有公共节点，都为null说明没有。类似于找环状链表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA === <span class="literal">null</span> || headB === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nodeA = headA;</span><br><span class="line">    <span class="keyword">var</span> nodeB = headB;</span><br><span class="line">    <span class="keyword">while</span>(nodeA !== nodeB)&#123;</span><br><span class="line">        nodeA = nodeA ? nodeA.next : headB;</span><br><span class="line">        nodeB = nodeB ? nodeB.next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Day13——双指针三（简单）"><a href="#Day13——双指针三（简单）" class="headerlink" title="Day13——双指针三（简单）"></a>Day13——双指针三（简单）</h1><h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h2><h3 id="示例-25"><a href="#示例-25" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;nums &#x3D; [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>输出:[1,3,2,4]<br/></p>
</blockquote>
<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>双指针，一根指向头，一根指向尾部，同时往中间移动</p>
<p>头部指针移动到第一个偶数位置停止</p>
<p>尾部指针移动到第一个奇数位置停止</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exchange = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nums.length) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) === <span class="number">1</span>) i++;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) === <span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">let</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">        nums[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a>剑指 Offer 57. 和为s的两个数字</h2><h3 id="示例-26"><a href="#示例-26" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br></pre></td></tr></table></figure>
<p>输出:[2,7] 或者 [7,2]<br/></p>
</blockquote>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p>头尾指针和小，头指针往后，和大，尾指针往前</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; j = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> [nums[i], nums[j]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] &gt; target)&#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)&#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h2><h3 id="示例-27"><a href="#示例-27" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&quot;  hello world!  &quot;</span><br></pre></td></tr></table></figure>
<p>输出:”world! hello”<br/><br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
</blockquote>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> wordArray = s.trim().split(<span class="string">' '</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = wordArray.length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = wordArray[i];</span><br><span class="line">        wordArray[i] = wordArray[j];</span><br><span class="line">        wordArray[j] = temp</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wordArray.join(<span class="string">' '</span>).trim()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Day14——搜索与回溯算法（中等）"><a href="#Day14——搜索与回溯算法（中等）" class="headerlink" title="Day14——搜索与回溯算法（中等）"></a>Day14——搜索与回溯算法（中等）</h1><h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p><img src="%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.jpeg" alt=""></p>
<h3 id="示例-28"><a href="#示例-28" class="headerlink" title="示例"></a>示例</h3><hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br></pre></td></tr></table></figure>
<p>输出:true<br/></p>
</blockquote>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p>回溯思想: 类似于在一个节点的枚举过程，不满足条件就回到那个节点</p>
<p>本题思路：</p>
<ol>
<li>从盘中任意一个节点开始走，因此是一个二重循环，需要考虑每一个节点，有一个节点满足则返回<code>true</code></li>
<li>对每一个节点进行枚举，不满足条件则回溯，满足条件的标记需要标记已经访问过了，避免再次访问</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exist = <span class="function"><span class="keyword">function</span>(<span class="params">board, word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> line = board.length;</span><br><span class="line">    <span class="keyword">const</span> column = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(line).fill(<span class="literal">false</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(column).fill(<span class="literal">false</span>))  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> checkWords = <span class="function">(<span class="params">i, j, _word, k</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 走的方向</span></span><br><span class="line">        <span class="keyword">const</span> directions = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">if</span>(board[i][j] !== word.charAt(k))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k === _word.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> [dx, dy] <span class="keyword">of</span> directions)&#123;</span><br><span class="line">            <span class="keyword">const</span> newX = i + dx;</span><br><span class="line">            <span class="keyword">const</span> newY = j + dy;</span><br><span class="line">            <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newX &lt;= line &amp;&amp; newY &lt;= column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[newX][newY])&#123;</span><br><span class="line">                    <span class="keyword">const</span> res = checkWords(newX, newY, _word, k + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">                        result = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; line;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; column;j++)&#123;</span><br><span class="line">            flag = checkWords(i, j, word, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><h3 id="示例-29"><a href="#示例-29" class="headerlink" title="示例"></a>示例</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以<strong>向左、右、上、下</strong>移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 <code>[35, 37]</code> ，因为<code>3+5+3+7=18</code>。但它不能进入方格 <code>[35, 38]</code>，因为<code>3+5+3+8=19</code>。请问该机器人能够到达多少个格子？</p>
<hr>
<blockquote>
<p>TIP <br/><br><br/><br>输入<br/></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>输出:3<br/></p>
</blockquote>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>是一个深度优先遍历或者广度优先遍历的题</p>
<p>深度优先遍历：相当于暴力的算法，一个方向走到底，然后回溯到节点再走</p>
<p>广度优先遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> movingCount = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="literal">false</span>)) <span class="comment">// 标记是否访问</span></span><br><span class="line">    <span class="keyword">const</span> calc = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x !== <span class="number">0</span>)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x = <span class="built_in">Math</span>.floor(x / <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> walk = <span class="function">(<span class="params">visit, m, n, i, j, k</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> sum = calc(i) + calc(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; k || visit[i][j] || i &gt; m || j &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        visit[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + walk(visit, m, n, i + <span class="number">1</span>, j, k) + walk(visit, m, n, i, j + <span class="number">1</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> walk(visited, m, n, <span class="number">0</span>, <span class="number">0</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>react-hook-form解决方案</title>
    <url>/2022/10/18/react-hook-form%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="选择的原因"><a href="#选择的原因" class="headerlink" title="选择的原因"></a>选择的原因</h2><p>公司本身使用<code>reduxForm</code>处理表单，也讨论过使用<code>antd</code>的表单，思考许久有以下问题:</p>
<p><strong>reduxForm</strong></p>
<p>不排除我对<code>reduxForm</code>理解不够深</p>
<ol>
<li><p><code>reduxForm</code>已经停止维护，表单过重，打包体积过大(24kb)，<code>react-hook-form</code> 8k</p>
</li>
<li><p><code>reduxForm</code>处理联动逻辑比较麻烦，没有一个可靠的<code>form</code>实例</p>
</li>
<li><p><code>reduxForm</code>联动改变数值不触发校验，手动触发校验方式比较<code>hack</code>(针对每个<code>Form</code>组件拿到实例手动触发<code>onBlur</code>校验)，其次校验<code>render</code>时机不正确，导致错误文案没法展示，项目中使用<code>setTimeout</code>解决</p>
</li>
<li><p><code>reduxForm</code>文档比较难读，对<code>Typescript</code>支持不友好</p>
</li>
<li><p><code>reduxForm</code>是采用高阶组件，对逻辑复杂的表单的<code>onChange</code>会有性能问题(卡顿，输不了值)，目前已经有<code>FormComponent</code>出现此问题</p>
</li>
</ol>
<p><strong>antd</strong></p>
<ol>
<li><p><code>antd</code>封装了一个完整的解决方案，底层使用<code>rc-field-form</code>，假如我们在<code>rc-field-form</code>到<code>Form</code>这个过程需要自定义业务，难以实现，并且有很多不需要的功能</p>
</li>
<li><p><code>antd</code>的表单再去封装动态表单难以实现，例如基于<code>antd</code>的<code>Form</code>去封装一个<code>ant-design-pro</code>的<code>ProForm</code>成本会激增</p>
</li>
<li><p><code>antd</code>的功能如果没有你想要的，无法去表单内部实现，只能通过其他方式，例如: <code>reduxForm</code>会对表单组件传递<code>dirty</code>判断数据是否被修改、<code>valid</code>判断校验是否通过(不触发<code>render</code>的情况下)</p>
</li>
<li><p><code>antd</code>是属于另一个<code>ui</code>库，与我们初始的<code>ui</code>选型不一致，<strong>无法单独引入<code>Form</code></strong>，<code>antd</code>的样式采用<code>module css</code>的方式，与<code>material-ui</code>的<code>css in js</code>的方式相违背，未来在<strong>主题</strong>上会出现很多问题</p>
</li>
</ol>
<h2 id="实现的目标"><a href="#实现的目标" class="headerlink" title="实现的目标"></a>实现的目标</h2><h3 id="静态表单"><a href="#静态表单" class="headerlink" title="静态表单"></a>静态表单</h3><p>表单数据都是以组件形式自己编写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Form&gt;</span><br><span class="line">    &lt;Form.Item name=<span class="string">"xx"</span>&gt;</span><br><span class="line">        &lt;FormComponent /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Form.Item&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Form&gt;</span><br></pre></td></tr></table></figure>

<p>目标: </p>
<p>借鉴<code>antd</code>，保留原项目<code>reduxForm</code>中好的东西，剔除<code>antd</code>不需要的功能，每一步流程都可以根据业务自定义</p>
<p>对项目的<code>Form</code>表单实现<strong>统一校验、统一联动校验、统一/自定义样式布局、类似于<code>antd中</code>常用的基础功能</strong></p>
<p>保留一定的可扩展性未来支持骨架屏，处理异步逻辑等等</p>
<h3 id="动态表单"><a href="#动态表单" class="headerlink" title="动态表单"></a>动态表单</h3><p>表单数据以<code>JSON schema</code>的格式配置，统一渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formField = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">'Input'</span></span><br><span class="line">        name: <span class="string">'xxx'</span>,</span><br><span class="line">        label: <span class="string">'xxx'</span>,</span><br><span class="line">        property: &#123;</span><br><span class="line">            ...<span class="comment">// 属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&lt;HookForm formField=&#123;formField&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>动态表单解决的问题:</p>
<ol>
<li><p><code>FormComponent</code>过多且布局较为统一</p>
</li>
<li><p>表单数据以<code>JSON Schema</code>的形式存储在后端</p>
</li>
</ol>
<p>目标: </p>
<p>功能上支持<strong>自定义校验、自定义组件配置、联动逻辑、表单动态的<code>props</code>传递</strong></p>
<h2 id="静态表单实现方式"><a href="#静态表单实现方式" class="headerlink" title="静态表单实现方式"></a>静态表单实现方式</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="%E9%9D%99%E6%80%81%E8%A1%A8%E5%8D%95.png" alt=""></p>
<h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><ol>
<li>处理<strong>用户对表单的全局监听</strong>，以及<code>hook-form</code>中提供的内置方法</li>
</ol>
<p><img src="%E8%87%AA%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt=""></p>
<ol start="2">
<li>处理<code>contextValue</code>，需要传递给<code>Form.Item</code>的全部放在contextValue下</li>
</ol>
<p><img src="context.png" alt=""></p>
<ol start="3">
<li>根据用户传递的<code>ref</code>，创建实例，抛出实例方法</li>
</ol>
<p><img src="form%E5%AE%9E%E4%BE%8B.png" alt=""></p>
<h3 id="Form-Item"><a href="#Form-Item" class="headerlink" title="Form.Item"></a>Form.Item</h3><ol>
<li>渲染<code>FormComponent</code>时对每一个<code>FormComponent</code>增加默认样式(<code>FieldWrap</code>)</li>
</ol>
<p><img src="fieldWrap.png" alt=""></p>
<ol start="2">
<li><p>针对没有提供<code>name</code>的<code>FormComponent</code>只渲染样式，数据不受<code>hook-form</code>控制</p>
</li>
<li><p>为用户提供单个<code>FormComponent</code>的监听(直接在<code>Form.Item</code>上传递<code>onChange</code>)</p>
</li>
<li><p>处理表单校验(默认校验、自定义校验)，<em>提供自定义校验会覆盖默认校验</em></p>
</li>
</ol>
<p><img src="Item%E6%A0%B8%E5%BF%83.png" alt=""></p>
<ol start="5">
<li>讲<code>hook-form</code>保存的<code>value</code>传递到表单组件用于受控，将改变<code>hook-form``FormComponent</code>的<code>onChange</code>传递到对应表单(<strong>即受控组件常用的value和onChange</strong>)</li>
</ol>
<h2 id="动态表单实现方式"><a href="#动态表单实现方式" class="headerlink" title="动态表单实现方式"></a>动态表单实现方式</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p><img src="%E5%8A%A8%E6%80%81%E8%A1%A8%E5%8D%95.png" alt=""></p>
<h3 id="HookForm"><a href="#HookForm" class="headerlink" title="HookForm"></a>HookForm</h3><ol>
<li><p><code>onTrigger</code>作为回调传递给<code>FieldRender</code>的<code>onChange</code>, 针对表单的每个<code>onChange</code>会判断是否满足联动逻辑<br><img src="HookForm.png" alt=""></p>
<h3 id="FieldRender"><a href="#FieldRender" class="headerlink" title="FieldRender"></a>FieldRender</h3></li>
<li><p>处理每个表单的统一校验，针对单个<code>FormComponent</code>的用户自定义校验</p>
</li>
<li><p>获取<code>FormComponent</code>的<code>props</code>, 包括了<code>JSON schema</code>中<code>property</code>属性下的、开发者<code>privateProps</code>以及全局的<code>publicProps</code></p>
</li>
</ol>
<p><img src="FieldRender.png" alt=""></p>
<h3 id="动态表单validate-ts"><a href="#动态表单validate-ts" class="headerlink" title="动态表单validate.ts"></a>动态表单validate.ts</h3><p>校验相关</p>
<p><img src="%E5%8A%A8%E6%80%81%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C.png" alt=""></p>
<h2 id="自定义表单组件"><a href="#自定义表单组件" class="headerlink" title="自定义表单组件"></a>自定义表单组件</h2><h3 id="编写方式"><a href="#编写方式" class="headerlink" title="编写方式"></a>编写方式</h3><p><strong>统一规定受控组件, 使用<code>TypeScript</code>编写</strong></p>
<ol>
<li><p><code>onChange</code>是<code>hook-form</code>的<code>onChange</code>, 用于改变表单的值</p>
</li>
<li><p><code>value</code>是<code>hook-form</code>数据池中的数据</p>
</li>
</ol>
<p><img src="FormComponent.png" alt=""></p>
<h3 id="FieldMap"><a href="#FieldMap" class="headerlink" title="FieldMap"></a>FieldMap</h3><p><img src="fieldMap.png" alt=""></p>
<h3 id="validate-ts"><a href="#validate-ts" class="headerlink" title="validate.ts"></a>validate.ts</h3><p><img src="ComponentValidate.png" alt=""></p>
<h2 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h2><ol>
<li>对应自定义的<code>FormComponent</code>的类型</li>
</ol>
<p><img src="FormComponentType.png" alt=""></p>
<ol start="2">
<li>对应<code>Form</code>实例<code>Type</code></li>
</ol>
<p><img src="FormType.png" alt=""></p>
<h2 id="不足与改进"><a href="#不足与改进" class="headerlink" title="不足与改进"></a>不足与改进</h2><ol>
<li><p>由于二级表单形式五花八门，不支持二级表单，目前也没想好怎么支持</p>
</li>
<li><p>默认的表单数据的类型应该作为泛型传入，而不是内置<code>HookFormData</code>传入，这样导致<code>submit</code>返回的类型与外部定义的类型不兼容，需要类型断言。写完后才发现，看了<code>antd</code>的<code>Form</code>也是那么做的，但是改动量过大</p>
</li>
<li><p>假如<code>Button</code>的按钮提交根据<em>是否校验通过</em>和<em>是否修改过默认表单</em>数据来判断是否<code>disable</code>，目前只能<code>render</code>在<code>&lt;Form&gt;&lt;/Form&gt;</code>组件的最后，不能自定义渲染位置。<code>reduxForm</code>是采用高阶组件的模式，会渲染全表单，与<code>hook-form</code>设计思想违背，<code>hook-form</code>将每个<code>FormComponent</code>与自身数据池隔离提升性能。目前也没有想到最优解</p>
</li>
<li><p><code>defaultFormData</code>可能是异步的，目前必须在无数据的时候不渲染<code>Form</code>，不然默认值设置不上去， 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如 asyncDefaultFormData 是异步获取的</span></span><br><span class="line">!asyncDefaultFormData ? <span class="literal">null</span> : <span class="xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">defaultFormData</span>=<span class="string">&#123;asyncDefaultFormData&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>工程化</tag>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器八股文(持续更新)</title>
    <url>/2022/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<p><em>只针对自己不太熟或者面试常问的有针对性的整理</em></p>
<h1 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h1><p>现代浏览器的多进程架构如下</p>
<p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" alt=""></p>
<p>多进程架构的优势：</p>
<p>各个进程<strong>相互独立，不会互相影响</strong>，不会因为一个进程的崩溃而影响整个浏览器的运行</p>
<p>浏览器主进程: 负责各个页面的展示交互</p>
<p>渲染进程: js引擎等</p>
<p>GPU进程：绘制ui界面</p>
<p>网络进程: 负责网络资源加载，<strong>浏览器的跨域从渲染进程发起，被网络进程拦截</strong></p>
<p>插件进程: 负责插件运行</p>
<h1 id="JavaScript单线程模型"><a href="#JavaScript单线程模型" class="headerlink" title="JavaScript单线程模型"></a>JavaScript单线程模型</h1><ol>
<li><p><code>GUI</code>线程与<code>js引擎线程</code><strong>互斥</strong></p>
</li>
<li><p><code>js</code>会阻塞页面加载</p>
</li>
<li><p><code>webWorker</code>可以再开启一个线程，但是这个线程由主线程控制，且不能操作<code>DOM</code>，但是<code>webWorker</code>需要通信，通信时长如果大于线程执行之间将得不偿失。</p>
</li>
</ol>
<h1 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93.png" alt=""></p>
<ol>
<li>解析<code>HTML</code>生成<code>DOM</code>树</li>
</ol>
<ul>
<li>期间如果遇到<code>脚本(js或者其他)</code>那么暂停解析，加载脚本，加载完重新构建<code>DOM</code>树</li>
</ul>
<ol start="2">
<li><p>解析<code>CSS</code>生成<code>CSSOM</code>树</p>
</li>
<li><p><code>DOM树</code>和<code>CSSOM树</code>合并生成<code>渲染树</code></p>
</li>
<li><p><code>渲染树</code>进行布局<code>layout</code>，计算节点的位置大小等等</p>
</li>
<li><p>调用<code>GPU绘制</code>，这个过程称为重绘</p>
</li>
</ol>
<h2 id="重绘回流"><a href="#重绘回流" class="headerlink" title="重绘回流"></a>重绘回流</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>回流：会计算布局的大小位置，重新生成<code>渲染树</code></p>
<ul>
<li><p>局部回流: 外层<code>dom</code>大小位置不变化，只变化了内层的</p>
</li>
<li><p>全局范围：从根节点开始回流</p>
</li>
</ul>
<p>重绘：只更改外观，<strong>不更改布局</strong></p>
<h3 id="针对回流优化"><a href="#针对回流优化" class="headerlink" title="针对回流优化"></a>针对回流优化</h3><ol>
<li><p>不要直接修改<code>DOM</code>中会改变定位或者大小的属性</p>
</li>
<li><p>不要过度的获取计算<code>DOM</code>的位置，大小</p>
</li>
<li><p><code>visibility</code>取代<code>display: none</code></p>
</li>
<li><p>频繁运行的动画使用<code>requestAnimationFrame</code>或者变成一个新的图层</p>
</li>
</ol>
<p>变图层的方式: </p>
<ul>
<li><p><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></p>
</li>
<li><p><code>will-change</code></p>
</li>
<li><p><code>video、iframe 标签</code></p>
</li>
<li><p><code>position: fixed</code></p>
</li>
</ul>
<h3 id="与EventLoop的关系"><a href="#与EventLoop的关系" class="headerlink" title="与EventLoop的关系"></a>与EventLoop的关系</h3><p><code>requestAnimationFrame</code>是一个能让<code>js</code>线程和浏览器交互的方法，这个函数传入的方法可以在浏览器重绘前调用,下面写一个简单的demo，让浏览器自己决定函数的触发时机保证不卡顿</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> ref;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params">temp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp - start &gt; <span class="number">100</span>)&#123;</span><br><span class="line">        start = temp;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    ref = <span class="built_in">window</span>.requestAnimationFrame(animation)</span><br><span class="line">&#125;</span><br><span class="line">ref = <span class="built_in">window</span>.requestAnimationFrame(animation)</span><br></pre></td></tr></table></figure>

<h2 id="其余渲染优化"><a href="#其余渲染优化" class="headerlink" title="其余渲染优化"></a>其余渲染优化</h2><ol>
<li><p><code>script</code>标签尽量放在后面，最好支持异步加载，最好支持延迟加载</p>
</li>
<li><p>尽可能快的加载<code>CSS</code>样式表，避免js加载时样式表还没加载完</p>
</li>
<li><p>适当使用图层</p>
</li>
</ol>
<ul>
<li>浏览器标准流可以视为一个图层，我们可以手动创建图层，脱离标准流，<strong>脱离标准流的图层会单独渲染</strong>，因此如果遇到渲染麻烦的图层我们可以单独为其创建一个图层渲染，但是不要过度使用，渲染本身也耗性能</li>
</ul>
<p>注意点：</p>
<ol>
<li><p><code>CSSOM</code>树的构建会影响<code>渲染树</code>的生成，因此<code>CSS</code>会影响页面渲染</p>
</li>
<li><p><code>HTML</code>标签遇到<code>script</code>标签会暂停构建，加载完后再去构建<code>DOM</code></p>
</li>
<li><p><code>script</code>标签引入的<code>js</code>文件，也需要在<code>css</code>样式表加载完之后才会执行</p>
</li>
</ol>
<h2 id="Load-和-DOMContentLoaded"><a href="#Load-和-DOMContentLoaded" class="headerlink" title="Load 和 DOMContentLoaded"></a>Load 和 DOMContentLoaded</h2><p><code>Load</code>是等<code>HTML、CSS、JS、图片等</code>资源都加载完时触发，可以用来计算首屏渲染时间</p>
<p><code>DOMContentLoaded</code>是<code>HTML</code>解析完成触发，不需要等待<code>CSS、JS、图片</code></p>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>强缓存：<code>Cache-Control</code> 和 <code>Expire</code></p>
<p>协商缓存：<code>If-none-match</code>配合<code>Etag</code> 和 <code>If-modified-since</code>配合<code>last-modified</code></p>
<p>优先强缓存，然后协商缓存</p>
<h1 id="存储方案"><a href="#存储方案" class="headerlink" title="存储方案"></a>存储方案</h1><p>Cookie：小 4k左右、会带到请求头<br>localStorage： 5m，需要手动清理<br>sessionStorage 5m，一直存在</p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>详细看<a href="https://auglyxu.github.io/2021/09/13/HTTP/#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">HTTP</a></p>
<h1 id="安全-XSS和CSRF"><a href="#安全-XSS和CSRF" class="headerlink" title="安全(XSS和CSRF)"></a>安全(XSS和CSRF)</h1><p>XSS：代码注入</p>
<ul>
<li>持久型：数据库代码注入</li>
<li>非持久: url代码注入(浏览器自动防范)</li>
</ul>
<p>CSP: 白名单(设置外部资源访问限制)，meta标签可以做<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p>
<p>CSRF: 跨站请求伪造，本站请求黑客服务器的方式来获取用户的信息</p>
<ul>
<li><code>cookie</code>设为同域</li>
<li>请求带上<code>token</code><h1 id="从输入URL到页面展示的过程-经典面试题"><a href="#从输入URL到页面展示的过程-经典面试题" class="headerlink" title="从输入URL到页面展示的过程(经典面试题)"></a>从输入URL到页面展示的过程(经典面试题)</h1></li>
</ul>
<ol>
<li>合成<code>url</code>，判断是否是一个合法的域名，非合法就调用浏览器默认搜索功能，合法就跳转到对应的网站</li>
<li><code>DNS</code>检索，检索优先从缓存中拿(浏览器缓存中 -&gt; 本地<code>HOST</code> -&gt; 本地<code>DNS</code>解析缓存 -&gt; 本地<code>DNS</code>服务器)，缓存中如果没有，依次查找根域名服务器、顶级域名服务器、二级域名服务器</li>
<li>建立<code>TCP</code>连接，<code>TCP</code>连接主要是三次握手</li>
</ol>
<ul>
<li>第一次：客户端发送标记位<code>SYN</code>, <code>seq = p</code></li>
<li>第二次：服务端响应<code>ACK</code>，<code>ack = p + 1</code>，请求建立连接标记位<code>SYN seq = q</code></li>
<li>第三次: 客户端响应标记位为<code>ACK ack = q + 1</code></li>
</ul>
<ol start="4">
<li><p>获取文件，优先从缓存中获取文件，<strong>优先强缓存</strong>，然后协商缓存</p>
</li>
<li><p>断开连接，TCP四次挥手</p>
</li>
</ol>
<ul>
<li>客户端发出标记位<code>FIN</code>，请求关闭</li>
<li>服务端发送标记位<code>ACK</code>，表示收到</li>
<li>服务端发出标记位<code>FIN</code>，表示可以关闭</li>
<li>客户端发出标记位<code>ACK</code>，表示收到</li>
<li>客户端等待两个<code>MSL</code>后断开连接</li>
</ul>
<ol start="6">
<li>获取文件后，解析HTML，渲染页面</li>
</ol>
<ul>
<li>解析HTML，生成 <code>DOM</code> 树， 解析<code>CSS</code>，生成<code>CSSOM</code>树</li>
<li>合并生成<code>render树</code></li>
<li>交由<code>GPU渲染</code>页面</li>
<li>交给浏览器绘制展示到页面上<h1 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h1></li>
</ul>
<p>层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p>拥有层叠上下文属性的元素会被提升为单独的一层。<br>拥有层叠上下文属性：</p>
<ul>
<li>根元素 (HTML),</li>
<li><code>z-index</code> 值不为 <code>&quot;auto&quot;</code>的 绝对/相对定位元素，</li>
<li><code>position</code>,固定<code>（fixed）</code> / 沾滞<code>（sticky）</code>定位（沾滞定位适配所有移动设- 备上的浏览器，但老的桌面浏览器不支持）</li>
<li><code>z-index</code>值不为 <code>&quot;auto&quot;</code>的 <code>flex</code> 子项 (<code>flex item</code>)，即：父元素 - <code>display: flex|inline-flex</code>，</li>
<li><code>z-index</code>值不为<code>&quot;auto&quot;</code>的<code>grid</code>子项，即：父元素<code>display：grid</code></li>
<li><code>opacity</code> 属性值<code>小于 1</code>的元素（参考 the specification for - opacity），</li>
<li><code>transform</code> 属性值不为 <code>&quot;none&quot;</code>的元素，</li>
<li><code>mix-blend-mode</code> 属性值不为 <code>&quot;normal&quot;</code>的元素，</li>
<li><code>filter</code>值不为<code>&quot;none&quot;</code>的元素，</li>
<li><code>perspective</code>值不为<code>&quot;none&quot;</code>的元素，</li>
<li><code>clip-path</code>值不为<code>&quot;none&quot;</code>的元素</li>
<li><code>mask / mask-image / mask-border</code>不为”none”的元素</li>
<li><code>isolation</code> 属性被设置为 <code>&quot;isolate&quot;</code>的元素</li>
<li>在 <code>will-change</code> 中指定了任意<code>CSS</code>属性</li>
<li><code>-webkit-overflow-scrolling</code> 属性被设置 “touch”的元素</li>
<li><code>contain</code>属性值为<code>&quot;layout&quot;</code>，<code>&quot;paint&quot;</code>，或者综合值比如<code>&quot;strict&quot;</code>，<code>&quot;content&quot;</code></li>
</ul>
<h1 id="requestAnimationFrame-和-requestIdleCallback"><a href="#requestAnimationFrame-和-requestIdleCallback" class="headerlink" title="requestAnimationFrame 和 requestIdleCallback"></a>requestAnimationFrame 和 requestIdleCallback</h1><p><code>requestAnimationFrame</code>浏览器渲染前调用，60刷新率大概为16.7ms</p>
<p><code>requestIdleCallback</code>，浏览器两帧间的<strong>空闲时间</strong>调用</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>发票匹配(待对账明细匹配)</title>
    <url>/2022/05/12/%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E6%89%8B%E5%8A%A8%E5%BD%95%E5%85%A5%E5%BE%85%E5%AF%B9%E8%B4%A6%E6%98%8E%E7%BB%86%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h2><p><img src="%E6%94%AF%E6%8C%81%E6%89%8B%E5%8A%A8%E5%8C%B9%E9%85%8D%E5%BE%85%E5%AF%B9%E8%B4%A6%E6%98%8E%E7%BB%86.png" alt="支持手动匹配待对账明细.png"></p>
<h2 id="与单配发票的区别"><a href="#与单配发票的区别" class="headerlink" title="与单配发票的区别"></a>与单配发票的区别</h2><table>
<thead>
<tr>
<th>单配发票</th>
<th>发票配待对账明细</th>
</tr>
</thead>
<tbody><tr>
<td>首先做准入性校验</td>
<td>不需要做准入性校验(发票采集已做)</td>
</tr>
<tr>
<td>优先后端自动匹配</td>
<td>用户选择明细匹配，提交校验</td>
</tr>
<tr>
<td>发票：单据明细 = 1:1</td>
<td>发票：单据明细 = n:n</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><p><img src="%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%E5%85%A5%E5%8F%A3%E4%BA%A4%E4%BA%92.png" alt="精确匹配入口交互.png"></p>
<p>对应的组件结构图<br><img src="%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E5%BE%85%E5%AF%B9%E8%B4%A6%E6%98%8E%E7%BB%86%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="发票匹配待对账明细组件结构图.png"></p>
<h3 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h3><p>与 <a href="https://auglyxu.github.io/2022/02/21/%E5%85%AC%E5%8F%B8%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1-%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E9%87%8D%E6%9E%84/">发票匹配2.0技术设计</a> 的流程中的手动匹配一致(去掉容差部分)，区别在于容差非前端计算</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><p>原数据结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单张发票对象 </span></span><br><span class="line">&#123;   </span><br><span class="line">    invoiceItems: [&#123;      </span><br><span class="line">        <span class="comment">// 单张发票匹配的单据      </span></span><br><span class="line">        sourceItems: [&#123;           </span><br><span class="line">            invoiceAmount: ,          </span><br><span class="line">            invoicedQuantity: , <span class="comment">// 数量          </span></span><br><span class="line">            totalAmountIncludedTax: , <span class="comment">// 含税金额          </span></span><br><span class="line">            totalAmountExcludedTax: , <span class="comment">// 未税金额           </span></span><br><span class="line">            totalTax: ,<span class="comment">// 税额           </span></span><br><span class="line">            ...     </span><br><span class="line">        &#125;],  </span><br><span class="line">    ]，</span><br><span class="line">    <span class="comment">// 发票明细      </span></span><br><span class="line">    status，</span><br><span class="line">    <span class="comment">// 发票验真状态      </span></span><br><span class="line">    errorCode, <span class="comment">// 准入性校验结果      </span></span><br><span class="line">    matchStatus，</span><br><span class="line">    <span class="comment">// 匹配结果     </span></span><br><span class="line">    matchResult， <span class="comment">// 容差匹配结果      </span></span><br><span class="line">    matchOffset， <span class="comment">// 模糊匹配后端返回容量      </span></span><br><span class="line">    leftCapacity: &#123;  <span class="comment">// 人工介入的剩余容量         </span></span><br><span class="line">        alert， <span class="comment">// 是否需要人工介入         </span></span><br><span class="line">        ... <span class="comment">// 剩下的就是容量字段      </span></span><br><span class="line">    &#125;，</span><br><span class="line">&#125;]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局数据管理</span></span><br><span class="line">referenceType: 匹配模式</span><br><span class="line">globalInvoice: 匹配的发票列表</span><br><span class="line">globalSourceItems: 全局的单据</span><br><span class="line">globalMatchedSourceItems: 全局匹配的单据</span><br><span class="line">globalUnMatchedSourceItems: 全局未匹配的单据</span><br><span class="line">globalMatchedSourceItemsMap: 全局匹配的单据code与对应金额数量映射表</span><br><span class="line">globalConfirmList: 全局待确认的映射表</span><br></pre></td></tr></table></figure>

<p>上一个版本发票明细：单据明细为多对多，但是发票明细只能存在于同一张发票中</p>
<p>这个版本需要修改数据结构，改成匹配关系更为明确的方式，要支持跨发票的发票明细多对多(即发票明细：单据明细 = n:n 并且 发票：单据明细 = n:n)</p>
<p>数据流设计与原发票基本一致，参考 <a href="https://maycur.yuque.com/bquybs/xm4vbx/cp5wop" target="_blank" rel="noopener">发票匹配2.0技术设计</a> 中的数据流设计，区别在于增加了全局的globalMatchGroupList</p>
<p>假如是<strong>发票与单据明细匹配</strong>， 那么groupId挂在发票对象上，如果是<strong>发票明细与单据明细匹配</strong>，那么groupId挂在发票明细对象上</p>
<p>一条发票明细只能存在于一个匹配组，对于未验真发票来说，一张发票也只能存在一个匹配组，并且对于未验真发票来说不能单独匹配</p>
<p>现有数据结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单张发票对象 </span></span><br><span class="line">&#123;   </span><br><span class="line">    invoiceItems: [&#123;      </span><br><span class="line">        <span class="comment">// 单张发票匹配的单据  </span></span><br><span class="line">        groupId, <span class="comment">// 多对多的话针对的是匹配组</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 发票明细      </span></span><br><span class="line">    status,</span><br><span class="line">    <span class="comment">// 发票验真状态      </span></span><br><span class="line">    errorCode, <span class="comment">// 准入性校验结果      </span></span><br><span class="line">    matchStatus，</span><br><span class="line">    <span class="comment">// 匹配结果     </span></span><br><span class="line">    matchResult， <span class="comment">// 容差匹配结果      </span></span><br><span class="line">    matchOffset， <span class="comment">// 模糊匹配后端返回容量      </span></span><br><span class="line">    groupId, <span class="comment">// 未验真发票匹配的单据(未验真发票没有明细)</span></span><br><span class="line">    leftCapacity: &#123;  <span class="comment">// 人工介入的剩余容量         </span></span><br><span class="line">        alert， <span class="comment">// 是否需要人工介入         </span></span><br><span class="line">        ... <span class="comment">// 剩下的就是容量字段      </span></span><br><span class="line">    &#125;，</span><br><span class="line">&#125;]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// globalMatchGroupList</span></span><br><span class="line">&#123;</span><br><span class="line">    matchGroupList: &#123;</span><br><span class="line">        <span class="number">1</span>: &#123;</span><br><span class="line">            invoiceItems: [],</span><br><span class="line">            sourceItems: [],</span><br><span class="line">            invoiceCode: <span class="number">12121212</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">2</span>: &#123;</span><br><span class="line">            invoiceItems: [],</span><br><span class="line">            sourceItems: [],</span><br><span class="line">            invoiceCode: <span class="number">12121212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局数据管理</span></span><br><span class="line">referenceType: 匹配模式</span><br><span class="line">globalInvoice: 匹配的发票列表</span><br><span class="line">globalSourceItems: 全局的单据</span><br><span class="line">globalMatchedSourceItems: 全局匹配的单据</span><br><span class="line">globalUnMatchedSourceItems: 全局未匹配的单据</span><br><span class="line">globalMatchedSourceItemsMap: 全局匹配的单据code与对应金额数量映射表</span><br><span class="line">globalConfirmList: 全局待确认的映射表</span><br><span class="line">globalMatchGroupList: 全局匹配的匹配组</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>业务</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
